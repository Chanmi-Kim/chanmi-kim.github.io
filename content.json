{"pages":[{"title":"About","text":"🙋‍ 안녕하세요!도전하는 것을 즐기고, 끊임없이 성장을 추구하는, 호기심대마왕주니어 개발자 김찬미입니다! 💻 찬미의 개발블로그Chanmi’s Devlog(찬미의 개발블로그)는아래와 같이 개발 및 기술에 대한 내용을 다루고자 운영중인 블로그입니다. 이슈 해결 관리 전공 및 개발 공부 개발일지 궁금하신 내용이나 틀린 내용이 있을 경우, 제 Github로 오셔서 Issues에 남겨주세요.혹은 게시물 댓글로 남겨주시면 감사드립니다! 📫 Contact Github: https://github.com/chanmi-kim Email: chanmi_dev@naver.com","link":"/About/index.html"}],"posts":[{"title":"알고리즘 | 삽입 정렬 (Insertion Sort)","text":"Algorithm : Insertion Sort(삽입 정렬) 삽입 정렬(Insertion Sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다. 예시문제 주어진 데이터를 Insertion Sort를 사용하여 정렬 하시오. 데이터의 최대 크기는 100이다. 입력 출력 1 // 전체 Test case 수 5 // 데이터 크기 1 4 5 2 3 #1 1 2 3 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Scanner; class Solution { static int input[]; static int num; static void insertionSort() { for (int i = 1; i &lt; num; i++) { int temp = input[i]; int j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; } } static void printResult() { int i; for (i = 0; i &lt; num; ++i) { System.out.print(input[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { num = sc.nextInt(); input = new int[num]; for (int i = 0; i &lt; num; i++) { input[i] = sc.nextInt(); } insertionSort(); System.out.print(\"#\" + test_case + \" \"); printResult(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt; #define MAX_NUM 100 int input[MAX_NUM];int num; void insertionSort(void){ int temp; int i; int j; for (i = 1; i &lt; num; i++) { temp = input[i]; j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; }} void printResult(void){ int i; for (i = 0; i &lt; num; ++i) { printf(\"%d \", input[i]); } printf(\"\\n\");} int main(void){ int T; int test_case; int i; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;num); for (i = 0; i &lt; num; i++) { scanf(\"%d\", &amp;input[i]); } insertionSort(); printf(\"#%d \", test_case); printResult(); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/24/Algorithm-Insertion-Sort/"},{"title":"알고리즘 | 재귀(Recursion)","text":"Algorithm : Recursion(재귀) 재귀(Recursion)는 수학이나 컴퓨터 과학 등에서 자신을 정의할 때 자기 자신을 재참조하는 방법을 뜻합니다. 주로 이 방법은 함수에 적용한 재귀 함수(Recursion Function)의 형태로 많이 사용됩니다. 예시문제 주어지는 수가 1 이상 20 이하의 수일 때, 주어진 수의 Factorial 값을 구해 아래와 같이 출력하시오. 입력 출력 3 // 전체 Test case 수 9 // Test case index 12 20 #1 9! = 362880 #2 12! = 479001600 #3 20! = 2432902008176640000 Java12345678910111213141516171819202122232425262728293031323334import java.util.Scanner; class Solution { static long factorial(int num) { if (num == 0) { return 1; } else { return num * factorial(num - 1); } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int num = sc.nextInt(); long value = factorial(num); System.out.println(\"#\" + test_case + \" \" + num + \"! = \" + value); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; long long factorial(int num){ if (num == 0) { return 1; } else { return num * factorial(num - 1); }} int main(void){ int test_case; int T; int num; long long value; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d\", &amp;num); value = factorial(num); printf(\"#%d %d! = %lld\\n\", test_case, num, value); }} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/20/Algorithm-Recursion/"},{"title":"알고리즘 | 퀵 정렬 (Quick Sort)","text":"Algorithm : Quick Sort(퀵 정렬) 퀵 정렬(Quick Sort)은 기준키(pivot)를 기준으로 작거나 같은 값을 지닌 데이터는 앞으로, 큰 값을 지닌 데이터는 뒤로 가도록 하여 작은 값을 갖는 데이터와 큰 값을 갖는 데이터로 분리해가며 정렬하는 방법입니다. 예시문제 주어진 데이터를 Quick Sort를 사용하여 정렬하시오. 데이터의 최대 크기는 100이다. 입력 출력 1 // 전체 Test case 수 5 // 데이터 크기 1 4 5 2 3 #1 1 2 3 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Scanner; class Solution { static int input[]; static int num; static void quickSort(int first, int last) { int temp; if (first &lt; last) { int pivot = first; int i = first; int j = last; while (i &lt; j) { while (input[i] &lt;= input[pivot] &amp;&amp; i &lt; last) { i++; } while (input[j] &gt; input[pivot]) { j--; } if (i &lt; j) { temp = input[i]; input[i] = input[j]; input[j] = temp; } } temp = input[pivot]; input[pivot] = input[j]; input[j] = temp; quickSort(first, j - 1); quickSort(j + 1, last); } } static void printResult() { for (int i = 0; i &lt; num; ++i) { System.out.print(input[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { num = sc.nextInt(); input = new int[num]; for (int i = 0; i &lt; num; i++) { input[i] = sc.nextInt(); } quickSort(0, num - 1); System.out.print(\"#\" + test_case + \" \"); printResult(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt; #define MAX_NUM 100 int input[MAX_NUM];int num; void quickSort(int first, int last){ int pivot; int i; int j; int temp; if (first &lt; last) { pivot = first; i = first; j = last; while (i &lt; j) { while (input[i] &lt;= input[pivot] &amp;&amp; i &lt; last) { i++; } while (input[j] &gt; input[pivot]) { j--; } if (i &lt; j) { temp = input[i]; input[i] = input[j]; input[j] = temp; } } temp = input[pivot]; input[pivot] = input[j]; input[j] = temp; quickSort(first, j - 1); quickSort(j + 1, last); }} void printResult(void){ int i; for (i = 0; i &lt; num; ++i) { printf(\"%d \", input[i]); } printf(\"\\n\");} int main(void){ int T; int test_case; int i; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;num); for (i = 0; i &lt; num; i++) { scanf(\"%d\", &amp;input[i]); } quickSort(0, num - 1); printf(\"#%d \", test_case); printResult(); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/29/Algorithm-Quick-Sort/"},{"title":"알고리즘 | 계수 정렬 (Counting Sort)","text":"Algorithm : Counting Sort(계수 정렬) 계수 정렬(Counting sort)는 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하면서 정렬하는 알고리즘입니다. 예시문제 주어진 정수들을 Counting Sort를 이용하여 정렬하고 오름차순으로 출력하라. (주어진 정수들은 중복가능) 입력 출력 2 // # of test case 10 // # of data set 0 2 9 4 5 1 0 7 3 9 5 4 9 5 1 3 #1 0 0 1 2 3 4 5 7 9 9 #2 1 3 4 5 9 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Scanner; class Solution { static final int MAX_N = 100; static final int MAX_DIGIT = 10; static int N; // # of data set static int arr[]; static int cnt[] = new int[MAX_DIGIT]; static int sortedArr[]; static void calculateDigitNumber() { for (int i = 0; i &lt; N; i++) { cnt[arr[i]]++; } for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = cnt[i-1] + cnt[i]; } } static void executeCountingSort() { for (int i = N-1; i &gt;= 0; i--) { sortedArr[--cnt[arr[i]]] = arr[i]; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { N = sc.nextInt(); arr = new int[N]; sortedArr = new int[N]; for (int i = 0; i &lt; N; i++) { arr[i] = sc.nextInt(); } // initialize for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = 0; } calculateDigitNumber(); executeCountingSort(); //print the sorted digits System.out.print(\"#\" + test_case + \" \"); for (int i = 0; i &lt; N; i++) { System.out.print(sortedArr[i] + \" \"); } System.out.println(); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt; #define MAX_N 100#define MAX_DIGIT 10 int N; // # of data setint arr[MAX_N];int cnt[MAX_DIGIT];int sortedArr[MAX_N]; void calculateDigitNumber(){ for (int i = 0; i &lt; N; i++) { cnt[arr[i]]++; } for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = cnt[i-1] + cnt[i]; }} void executeCountingSort(){ for (int i = N-1; i &gt;= 0; i--) { sortedArr[--cnt[arr[i]]] = arr[i]; }} int main(void){ int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;arr[i]); } // initialize for (int i = 1; i &lt; MAX_DIGIT; i++) { cnt[i] = 0; } calculateDigitNumber(); executeCountingSort(); //print the sorted digits printf(\"#%d \", test_case); for (int i = 0; i &lt; N; i++) { printf(\"%d \", sortedArr[i]); } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/30/Algorithm-Counting-Sort/"},{"title":"알고리즘 | 이진 탐색 (Binary Search)","text":"Algorithm : Binary Search(이진 탐색) 이진 탐색 알고리즘(Binary search algorithm)은 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘입니다. 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있습니다. 만약 처음 선택한 중앙값이 찾는 값보다 크면 그 값은 새로운 최고값이 되고, 작으면 그 값은 새로운 최하값이 됩니다. 예시문제 정렬된 정수배열에서 Binary Search를 이용하여 제시된 숫자들을 찾아라. 있으면 해당 인덱스를 출력하고, 없으면 -1 를 출력하라. (2 ≤ M ≤ 100) 입력 출력 2 // # of test case T 12 // # of element in array M 5 // # of numbers to search N 3 7 28 29 43 49 55 58 69 77 79 99 // sorted integer array 8 49 58 44 7 // numbers to search 7 3 3 4 5 6 7 8 9 1 2 3 #1 -1 5 7 -1 1 #2 -1 -1 0 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Scanner; class Solution { static final int MAX_M = 100; static int T; // # of test case static int M; // # of element in array static int N; // # of numbers to search static int arr[]; static void binarySearch(int[] arr, int low, int high, int target) { int mid; if (low &gt; high) { System.out.print(\"-1 \"); return; } mid = (low + high) / 2; if (target &lt; arr[mid]) { binarySearch(arr, low, mid - 1, target); } else if (arr[mid] &lt; target) { binarySearch(arr, mid + 1, high, target); } else { System.out.print(mid + \" \"); return; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { System.out.print(\"#\" + test_case + \" \"); M = sc.nextInt(); N = sc.nextInt(); arr = new int[M]; for (int i = 0; i &lt; M; i++) { arr[i] = sc.nextInt(); } for (int i = 0; i &lt; N; i++) { int targetValue = sc.nextInt(); binarySearch(arr, 0, M-1, targetValue); } System.out.println(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt; #define MAX_M 100 int T; // # of test caseint M; // # of element in arrayint N; // # of numbers to searchint arr[MAX_M]; void binarySearch(int* arr, int low, int high, int target){ int mid; if (low &gt; high) { printf(\"-1 \"); return; } mid = (low + high) / 2; if (target &lt; arr[mid]) { binarySearch(arr, low, mid - 1, target); } else if (arr[mid] &lt; target) { binarySearch(arr, mid + 1, high, target); } else { printf(\"%d \", mid); return; }} int main(void){ int targetValue; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { printf(\"#%d \", test_case); scanf(\"%d %d\", &amp;M, &amp;N); for (int i = 0; i &lt; M; i++) { scanf(\"%d\", &amp;arr[i]); } for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;targetValue); binarySearch(arr, 0, M-1, targetValue); } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/31/Algorithm-Binary-Search/"},{"title":"알고리즘 | 깊이 우선 탐색 (DFS Searching)","text":"Algorithm : DFS Searching (깊이 우선 탐색) 깊이 우선 탐색(DFS Searching, Depth First Searching)은 맹목적 탐색방법의 하나로 한 노드를 시작으로 인접한 다른 노드를 재귀적으로 탐색해가고 끝까지 탐색하면 다시 위로 와서 다음을 탐색하여 검색합니다. 예시문제 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. 정점의 최대 개수는 30개이다. 정점과 정점의 연결관계가 인접행렬로 주어졌을 때, DFS를 이용하여 시작 정점으로부터 모든 정점을 탐색한 결과를 순서대로 화면에 출력하시오. 입력 출력 1 //test case 개수 8 1 // 정점의 개수, 시작 정점 1 2 // 정점 간 연결 관계. 1과 2가 연결 1 3 2 4 2 5 4 8 5 8 3 6 3 7 6 8 7 8 -1 -1 // 입력 끝 #1 1 2 4 8 5 6 3 7 // 방문한 정점 순서 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner; class Solution { static final int MAX_VERTEX = 30; static int vertex; static int map[][] = new int[MAX_VERTEX][MAX_VERTEX]; static int visit[] = new int[MAX_VERTEX]; static void depthFirstSearch(int v) { visit[v] = 1; for (int i = 1; i &lt;= vertex; i++) { if (map[v][i] == 1 &amp;&amp; visit[i] == 0) { System.out.printf(\"%d \", i); depthFirstSearch(i); } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { vertex = sc.nextInt(); int start = sc.nextInt(); map = new int[MAX_VERTEX][MAX_VERTEX]; visit = new int[MAX_VERTEX]; while (true) { int v1 = sc.nextInt(); int v2 = sc.nextInt(); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } System.out.printf(\"#%d \", test_case); System.out.printf(\"%d \", start); depthFirstSearch(start); System.out.printf(\"\\n\"); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt; #define MAX_VERTEX 30 int vertex;int map[MAX_VERTEX][MAX_VERTEX];int visit[MAX_VERTEX]; void depthFirstSearch(int v){ int i; visit[v] = 1; for (i = 1; i &lt;= vertex; i++) { if (map[v][i] == 1 &amp;&amp; !visit[i]) { printf(\"%d \", i); depthFirstSearch(i); } }} int main(void){ int T; int test_case; int i,j; int start; int v1; int v2; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { for (i = 0; i &lt; MAX_VERTEX; i++) { for (j = 0; j &lt; MAX_VERTEX; j++) { map[i][j] = 0; } visit[i] = 0; } scanf(\"%d %d\", &amp;vertex, &amp;start); while (true) { scanf(\"%d %d\", &amp;v1, &amp;v2); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } printf(\"#%d \", test_case); printf(\"%d \", start); depthFirstSearch(start); printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/01/Algorithm-DFS-Searching/"},{"title":"알고리즘 | 너비 우선 탐색 (BFS Searching)","text":"Algorithm : BFS Searching (너비 우선 탐색) 너비 우선 탐색(BFS Searching, Breadth First Search)은 맹목적 탐색방법의 하나로 시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법입니다. 예시문제 숫자가 있는 원은 정점(Vertex)라고 하고, 정점과 정점을 잇는 연결선을 간선(Edge)이라고 한다. 정점의 최대 개수는 30개이다. 정점과 정점의 연결관계가 인접행렬로 주어졌을 때, BFS를 이용하여 시작 정점으로부터 모든 정점을 탐색한 결과를 순서대로 화면에 출력하시오. 입력 출력 1 //test case 개수 8 1 // 정점의 개수, 시작 정점 1 2 // 정점 간 연결 관계. 1과 2가 연결 1 3 2 4 2 5 4 8 5 8 3 6 3 7 6 8 7 8 -1 -1 // 입력 끝 #1 1 2 3 4 5 6 7 8 // 방문한 정점 순서 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner; class Solution { static final int MAX_VERTEX = 30; static int num; static int map[][]; static int visit[]; static int queue[]; static int rear, front; static void breadthFirstSearch(int vertex) { visit[vertex] = 1; System.out.print(vertex + \" \"); queue[rear++] = vertex; while (front &lt; rear) { vertex = queue[front++]; for (int i = 1; i &lt;= num; i++) { if (map[vertex][i] == 1 &amp;&amp; visit[i] == 0) { visit[i] = 1; System.out.printf(\"%d \", i); queue[rear++] = i; } } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { map = new int[MAX_VERTEX][MAX_VERTEX]; visit = new int[MAX_VERTEX]; queue = new int[MAX_VERTEX]; num = sc.nextInt(); int start = sc.nextInt(); while (true) { int v1 = sc.nextInt(); int v2 = sc.nextInt(); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } System.out.printf(\"#%d \", test_case); breadthFirstSearch(start); System.out.printf(\"\\n\"); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt; #define MAX_VERTEX 30 int num;int map[MAX_VERTEX][MAX_VERTEX];int visit[MAX_VERTEX];int queue[MAX_VERTEX];int rear, front; void breadthFirstSearch(int vertex){ int i; visit[vertex] = 1; printf(\"%d \", vertex); queue[rear++] = vertex; while (front &lt; rear) { vertex = queue[front++]; for (i = 1; i &lt;= num; i++) { if (map[vertex][i] == 1 &amp;&amp; !visit[i]) { visit[i] = 1; printf(\"%d \", i); queue[rear++] = i; } } }} int main(void){ int T; int test_case; int i,j; int start; int v1; int v2; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { for (i = 0; i &lt; MAX_VERTEX; i++) { for (j = 0; j &lt; MAX_VERTEX; j++) { map[i][j] = 0; } visit[i] = 0; queue[i] = 0; } front = 0; rear = 0; scanf(\"%d %d\", &amp;num, &amp;start); while (true) { scanf(\"%d %d\", &amp;v1, &amp;v2); if (v1 == -1 &amp;&amp; v2 == -1) { break; } map[v1][v2] = map[v2][v1] = 1; } printf(\"#%d \", test_case); breadthFirstSearch(start); printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/02/Algorithm-BFS-Searching/"},{"title":"알고리즘 | 매개변수 탐색 (Parametric Search)","text":"Algorithm : Parametric Search (매개변수 탐색) 매개변수 탐색(Parametric Search)은 어떤 알고리즘으로 해를 바로 구해내는 것이 아니고, 임의의 값을 던지고 맞는지 확인해가며 해를 구하는 방법입니다. 예시문제 길이가 각각 다른 K개의 리본을 가지고 있다. 공예작품을 만들기 위해 가지고 있는 리본을 잘라서 길이가 동일한 N개의 리본재료를 만들려고 한다. 리본재료의 최대 길이를 구하시오. ( 1 &lt;= K &lt;= 10,000; 1 &lt;= N &lt;= 1,000,000; K &lt;= N ) 손실되는 길이는 없음 만들 수 없는 경우는 없다 이미 자른 리본은 붙일 수 없다 자를 때는 정수 cm 단위로 자른다 입력 출력 1 // test case 개수 4 // 가지고 있는 리본의 개수 K 11 // 필요한 리본재료의 개수 N 802 743 457 539 #1 200 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Scanner; class Solution { static int K; static int N; static int low, high, mid, numRibbonTape, max; static int sizeRibbonTape[]; static void search() { mid = low + (high - low) / 2; numRibbonTape = 0; for (int i = 0; i &lt; K ; i++) { numRibbonTape += (sizeRibbonTape[i] / mid); } if (numRibbonTape &gt;= N) { low = mid + 1; if (max &lt; mid) max = mid; } else { high = mid - 1; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { low = 1; high = 0 ; max = -1; K = sc.nextInt(); N = sc.nextInt(); sizeRibbonTape = new int[K]; for (int i = 0; i &lt; K; i++) { sizeRibbonTape[i] = sc.nextInt(); if ( high &lt; sizeRibbonTape[i] ) { high = sizeRibbonTape[i] ; } } while (low &lt;= high) { search(); } System.out.println(\"#\" + test_case + \" \" + max); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt; #define MAX_RIBBON 100 int K;int N;int low, high, mid, numRibbonTape, max;int sizeRibbonTape[MAX_RIBBON]; void search(){ mid = low + (high - low) / 2; numRibbonTape = 0; for (int i = 0; i &lt; K ; i++) { numRibbonTape += (sizeRibbonTape[i] / mid); } if (numRibbonTape &gt;= N) { low = mid + 1; if (max &lt; mid) max = mid; } else { high = mid - 1; }} int main(int argc, char** argv){ int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { low = 1; high = 0 ; max = -1; scanf(\"%d %d\", &amp;K, &amp;N); for (int i = 0; i &lt; K; i++) { scanf(\"%d\", &amp;sizeRibbonTape[i]); if ( high &lt; sizeRibbonTape[i] ) { high = sizeRibbonTape[i] ; } } while (low &lt;= high) { search(); } printf(\"#%d \", test_case); printf(\"%d\\n\", max); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/03/Algorithm-Parametric-Search/"},{"title":"알고리즘 | 동적 계획법 (Dynamic Programming)","text":"Algorithm : Dynamic Programming (동적 계획법) 동적 계획법(Dynamic programming)은 복잡한 문제를 풀기위해서 간단한 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 목적에 도달하는 방법입니다. 예시문제 상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다. 상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다. 입력 출력 2 5 50 10 100 20 40 30 50 70 10 60 7 10 30 10 50 100 20 40 20 40 30 50 60 20 80 #1 260 #2 290 Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Scanner; class Solution { static int N; static int dp[][]; static int board[][]; static int max(int a, int b) { return (a&lt;b) ? b : a; } static void findSticker() { dp[0][0] = board[0][0]; dp[1][0] = board[1][0]; dp[0][1] = dp[1][0] + board[0][1]; dp[1][1] = dp[0][0] + board[1][1]; for (int i = 2; i &lt; N; i++) { dp[0][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[0][i] = max(dp[1][i - 1], dp[0][i]); dp[0][i] += board[0][i]; dp[1][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[1][i] = max(dp[0][i - 1], dp[1][i]); dp[1][i] += board[1][i]; } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { N = sc.nextInt(); board = new int[2][N]; dp = new int[2][N]; for (int j = 0; j &lt; 2; j++) { for (int i = 0; i &lt; N; i++) { board[j][i] = sc.nextInt(); } } findSticker(); System.out.println(\"#\" + test_case + \" \" + max(dp[0][N - 1], dp[1][N - 1])); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt; int N;int dp[2][100001];int board[2][100001]; const int max(const int a, const int b) { return (a&lt;b) ? b : a;} void findSticker() { dp[0][0] = board[0][0]; dp[1][0] = board[1][0]; dp[0][1] = dp[1][0] + board[0][1]; dp[1][1] = dp[0][0] + board[1][1]; for (int i = 2; i &lt; N; i++) { dp[0][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[0][i] = max(dp[1][i - 1], dp[0][i]); dp[0][i] += board[0][i]; dp[1][i] = max(dp[0][i - 2], dp[1][i - 2]); dp[1][i] = max(dp[0][i - 1], dp[1][i]); dp[1][i] += board[1][i]; }} int main() { int T; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { printf(\"#%d \", test_case); scanf(\"%d\", &amp;N); for (int j = 0; j &lt; 2; j++) { for (int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;board[j][i]); } } findSticker(); printf(\"%d\\n\", max(dp[0][N - 1], dp[1][N - 1])); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/04/Algorithm-Dynamic-Programming/"},{"title":"알고리즘 | 순열 조합 (Permutation & Combination)","text":"Algorithm : Permutation &amp; Combination (순열 조합) 순열(Permutation)은 순서가 부여된 임의의 집합을 다른 순서로 뒤섞는 연산이며, 조합(Combination)은 집합에서 일부 원소를 취해 부분 집합을 만드는 방법을 말합니다. 예시문제 주어진 문자열 str (길이 n)에 대해 아래 두 가지를 차례로 출력하시오. 1. str의 n개 character를 일렬로 배열하는 모든 경우를 출력하시오. 2. str의 n개 character 중 k개를 취하는 모든 경우를 출력하시오. (제한사항: 주어진 string에 동일한 알파벳이 중복으로 포함되지 않음. String의 maximum size는 10. k &lt;= n.) 입력 출력 1 // # of test case ABCD 3 // n 2 // k #1 ABC ACB BAC BCA CBA CAB AB AC BC Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.Scanner; class Solution{ static final int MAX_STRING_LENGTH = 10; static int stackTop = 0; static char[] combinationStack = new char[MAX_STRING_LENGTH]; static void printCString(char[] str) { for (int i = 0; i &lt; str.length &amp;&amp; str[i] != 0; i++) { System.out.print(str[i]); } System.out.print(\"\\n\"); } static void swap(char[] str, int x, int y) { char temp = str[x]; str[x] = str[y]; str[y] = temp; } static void permutation(char[] str, int l, int r) { if (l == r) { printCString(str); } else { for (int i = l; i &lt;= r; i++) { swap(str, l, i); permutation(str, l+1, r); swap(str, l, i); //backtrack } } } static void push(char ch) { combinationStack[stackTop++] = ch; combinationStack[stackTop] = '\\0'; } static void pop() { combinationStack[--stackTop] = '\\0'; } static void combination(char[] str, int length, int offset, int k) { if (k == 0) { printCString(combinationStack); return; } for (int i = offset; i &lt;= length - k; ++i) { push(str[i]); combination(str, length, i+1, k-1); pop(); } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { String input = sc.next(); int N = sc.nextInt(); int K = sc.nextInt(); char[] str = input.toCharArray(); System.out.printf(\"#%d\\n\", test_case); str[N] = 0; permutation(str, 0, N-1); combination(str, N, 0, K); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt; #define MAX_STRING_LENGTH 10 int stackTop = 0;char combinationStack[MAX_STRING_LENGTH]; void swap(char *x, char *y){ char temp; temp = *x; *x = *y; *y = temp;} void permutation(char *str, int l, int r){ if (l == r) { printf(\"%s\\n\", str); } else { for (int i = l; i &lt;= r; i++) { swap((str+l), (str+i)); permutation(str, l+1, r); swap((str+l), (str+i)); //backtrack } }} void push(char ch) { combinationStack[stackTop++] = ch; combinationStack[stackTop] = '\\0';} void pop() { combinationStack[--stackTop] = '\\0';} void combination(const char* str, int length, int offset, int k) { if (k == 0) { printf(\"%s\\n\", combinationStack); return; } for (int i = offset; i &lt;= length - k; ++i) { push(str[i]); combination(str, length, i+1, k-1); pop(); }} int main(){ int N, K, T; char str[MAX_STRING_LENGTH]; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%s%d%d\", str, &amp;N, &amp;K); str[N] = 0; printf(\"#%d\\n\", test_case); permutation(str, 0, N-1); combination(str, N, 0, K); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/05/Algorithm-Permutation-and-Combination/"},{"title":"알고리즘 | 다익스트라 (Dijkstra)","text":"Algorithm : Dijkstra (다익스트라) 다익스트라 알고리즘(Dijkstra)은 어떤 변도 음수 가중치를 갖지 않는 유향 그래프에서 주어진 출발점과 도착점 사이의 최단 경로 문제를 푸는 알고리즘입니다. 예시문제 방향이 있는 그래프에서 꼭지점들을 연결하는 비용이 할당 되었을 때 임의의 꼭지점에서 다른 꼭지점으로 가는 경로들 중에서 비용이 가장 적게 드는 경로, 즉 두 정점 사이의 최단 경로를 찾아라. 입력 값 첫번째 라인에는 전체 테스트 케이스의 개수가 입력된다. 두번째 라인에는 정점의 개수, 그리고 시작 정점, 도착 정점이 입력된다. 이때, 정점의 최대 개수는 100이다. 세번째 라인에는 정점을 잇는 간선 개수(m)가 입력된다. 네번째 라인부터는 연결 된 정점 값 2개와 간선에 할당 된 비용이 m번 들어온다. 이때 간선 방향은 첫번째 입력된 정점에서 두번째 입력된 정점으로 가는 방향이다. 입력 출력 1 // test case 개수 7 1 7 // 정점의 개수, 그리고 시작 정점, 도착 정점 9 // 간선 개수 1 2 4 // 1-&gt;2, 비용은 4 1 3 2 2 4 1 2 5 2 3 4 7 3 6 3 4 7 3 5 7 1 6 7 5 #1 7 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Scanner; class Solution{ static final int N = 100; static final int INF = 100000; static int[][] map = new int[N+1][N+1]; static boolean[] visit = new boolean[N+1]; static int[] dist = new int[N+1]; static int vertex; static int edge; static int start; static int end; public static void dijkstra() { int v = 0; dist[start] = 0; for (int i = 1; i &lt;= vertex; i++) { int min = INF; for (int j = 1; j &lt;= vertex; j++) { if (visit[j] == false &amp;&amp; min &gt; dist[j]) { min = dist[j]; v = j; } } visit[v] = true; for (int j = 1; j &lt;= vertex; j++) { if (dist[j] &gt; dist[v] + map[v][j]) { dist[j] = dist[v] + map[v][j]; } } } } public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { vertex = sc.nextInt(); start = sc.nextInt(); end = sc.nextInt(); edge = sc.nextInt(); for (int i = 1; i &lt;= vertex; i++) { for (int j = 1; j &lt;= vertex; j++) { if (i != j) { map[i][j] = INF; } } } for (int i = 1; i &lt;= edge; i++) { int from = sc.nextInt(); int to = sc.nextInt(); int value = sc.nextInt(); map[from][to] = value; } for (int i = 1; i &lt;= vertex; i++) { dist[i] = INF; visit[i] = false; } dijkstra(); System.out.printf(\"#%d %d\\n\", test_case, dist[end]); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt; #define N 100#define INF 100000 int map[N + 1][N + 1];int visit[N + 1];int dist[N + 1];int vertex;int edge;int start;int end; void dijkstra(void){ int i; int j; int min; int v; dist[start] = 0; for (i = 1; i &lt;= vertex; i++) { min = INF; for (j = 1; j &lt;= vertex; j++) { if (visit[j] == 0 &amp;&amp; min &gt; dist[j]) { min = dist[j]; v = j; } } visit[v] = 1; for (j = 1; j &lt;= vertex; j++) { if (dist[j] &gt; dist[v] + map[v][j]) { dist[j] = dist[v] + map[v][j]; } } }} int main(void){ int test_case; int T; int i; int j; int from; int to; int value; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d %d %d\", &amp;vertex, &amp;start, &amp;end); scanf(\"%d\", &amp;edge); for (i = 1; i &lt;= vertex; i++) { for (j = 1; j &lt;= vertex; j++) { if (i != j) { map[i][j] = INF; } } } for (i = 1; i &lt;= edge; i++) { scanf(\"%d %d %d\", &amp;from, &amp;to, &amp;value); map[from][to] = value; } for (i = 1; i &lt;= vertex; i++) { dist[i] = INF; visit[i] = 0; } printf(\"#%d \", test_case); dijkstra(); printf(\"%d \\n\", dist[end]); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/08/07/Algorithm-Dijkstra/"},{"title":"자료구조 | 큐 (Queue)","text":"Data Structure : Queue(큐) 큐는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말합니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Queue에 넣은 후 하나씩 꺼내 화면에 출력하시오. 입력 출력 2 // 테스트 케이스 수 5 // 데이터 크기 1 2 3 4 5 5 5 4 2 3 1 #1 1 2 3 4 5 #2 5 4 2 3 1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Solution { static final int MAX_N = 100; static int front; static int rear; static int queue[] = new int[MAX_N]; static void queueInit() { front = 0; rear = 0; } static boolean queueIsEmpty() { return (front == rear); } static boolean queueIsFull() { if ((rear + 1) % MAX_N == front) { return true; } else { return false; } } static boolean queueEnqueue(int value) { if (queueIsFull()) { System.out.print(\"queue is full!\"); return false; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return true; } static Integer queueDequeue() { if (queueIsEmpty()) { System.out.print(\"queue is empty!\"); return null; } Integer value = new Integer(queue[front]); front++; if (front == MAX_N) { front = 0; } return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); queueInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); queueEnqueue(value); } System.out.print(\"#\" + test_case + \" \"); while (!queueIsEmpty()) { Integer value = queueDequeue(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt; #define MAX_N 100 int front;int rear;int queue[MAX_N]; void queueInit(void){ front = 0; rear = 0;} int queueIsEmpty(void){ return (front == rear);} int queueIsFull(void){ if ((rear + 1) % MAX_N == front) { return 1; } else { return 0; }} int queueEnqueue(int value){ if (queueIsFull()) { printf(\"queue is full!\"); return 0; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return 1;} int queueDequeue(int *value){ if (queueIsEmpty()) { printf(\"queue is empty!\"); return 0; } *value = queue[front]; front++; if (front == MAX_N) { front = 0; } return 1;} int main(int argc, char* argv[]){ int T; int N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); queueInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); queueEnqueue(value); printf(\"setValue\"); } printf(\"#%d \", test_case); while (!queueIsEmpty()) { int value; if (queueDequeue(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/22/Data-Structure-Queue/"},{"title":"자료구조 | 우선순위 큐 (Priority Queue)","text":"Data Structure : Priority Queue(우선순위 큐) 우선순위 큐는 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리되는 자료구조입니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 작은 숫자가 높은 우선순위를 갖는 Priority Queue에 저장하고, 우선 순위가 높은 숫자부터 차례대로 출력하시오.(입력에는 오류가 없다고 가정) 입력 출력 2 //테스트 케이스 수 10 //입력 수 10 49 38 17 56 92 8 1 13 55 //입력 데이터 13 4 22 50 13 5 1 22 35 21 7 99 100 14 #1 1 8 10 13 17 38 49 55 56 92 #2 1 4 5 7 13 14 21 22 22 35 50 99 100 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.Scanner; class Solution { static Scanner sc; static final int MAX_SIZE = 100; static int heap[] = new int[MAX_SIZE]; static int heapSize = 0; static void heapInit() { heapSize = 0; } static void heapPush(int value) { if (heapSize + 1 &gt; MAX_SIZE) { return; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; } static int heapPop() { if (heapSize &lt;= 0) { return -1; } int value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current &lt; heapSize &amp;&amp; current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 &gt;= heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return value; } static void heapPrint(int[] heap, int heap_size) { for (int i = 0; i &lt; heap_size; i++) { System.out.print(heap[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); heapInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); heapPush(value); } System.out.print(\"#\" + test_case + \" \"); for (int i = 0; i &lt; N; i++) { System.out.print(heapPop() + \" \"); } System.out.println(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt; #define MAX_SIZE 100 int heap[MAX_SIZE];int heapSize = 0; void heapInit(void){ heapSize = 0;} int heapPush(int value){ if (heapSize + 1 &gt; MAX_SIZE) { printf(\"queue is full!\"); return 0; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; return 1;} int heapPop(int *value){ if (heapSize &lt;= 0) { return -1; } *value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 == heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); heapInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); heapPush(value); } printf(\"#%d \", test_case); for (int i = 0; i &lt; N; i++) { int value; heapPop(&amp;value); printf(\"%d \", value); } printf(\"\\n\"); } return 0;} [참고차료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/23/Data-Structure-Priority-Queue/"},{"title":"자료구조 | 해시 (Hash)","text":"Data Structure : Hash(해시) 해시 테이블(Hash table)은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추가에 사용되는 자료 구조입니다. 해시 테이블은 해시 함수를 사용하여 색인(index, Key)을 버킷(bucket)이나 슬롯(slot)의 배열로 계산합니다. 예시문제 주어진 N개의 key, data쌍을 Hash table에 입력한 후, Q개의 key를 입력 받아 key에 해당하는 data를 각 줄에 출력하시오. (1&lt;=N, Q&lt;=4096) Key : 최대 64개의 문자열 Data : 최대 128개의 문자열 입력 출력 123123123234serf 234sdfdfgdcvb Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Hashtable{ class Hash { String key; String data; } int capacity; Hash tb[]; public Hashtable(int capacity){ this.capacity = capacity; tb = new Hash[capacity]; for (int i = 0; i &lt; capacity; i++){ tb[i] = new Hash(); } } private int hash(String str) { int hash = 5381; for (int i = 0; i &lt; str.length(); i++) { int c = (int)str.charAt(i); hash = ((hash &lt;&lt; 5) + hash) + c; } if (hash &lt; 0) hash *= -1; return hash % capacity; } public String find(String key){ int h = hash(key); int cnt = capacity; while(tb[h].key != null &amp;&amp; (--cnt) != 0) { if (tb[h].key.equals(key)){ return tb[h].data; } h = (h + 1) % capacity; } return null; } boolean add(String key, String data) { int h = hash(key); while(tb[h].key != null) { if (tb[h].key.equals(key)){ return false; } h = (h + 1) % capacity; } tb[h].key = key; tb[h].data = data; return true; }} class Solution{ final static int MAX_TABLE = 4096; public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { Hashtable tb = new Hashtable(MAX_TABLE); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { String k = sc.next(); String d = sc.next(); tb.add(k, d); } System.out.printf(\"#%d\\n\", test_case); int Q = sc.nextInt(); for (int i = 0; i &lt; Q; i++) { String k = sc.next(); String d = tb.find(k); if (d != null) { System.out.printf(\"%s\\n\", d); } else { System.out.printf(\"not find\\n\"); } } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt; #define MAX_KEY 64#define MAX_DATA 128#define MAX_TABLE 4096 typedef struct{ char key[MAX_KEY + 1]; char data[MAX_DATA + 1];}Hash;Hash tb[MAX_TABLE]; unsigned long hash(const char *str){ unsigned long hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;} int find(const char *key, char *data){ unsigned long h = hash(key); int cnt = MAX_TABLE; while (tb[h].key[0] != 0 &amp;&amp; cnt--) { if (strcmp(tb[h].key, key) == 0) { strcpy(data, tb[h].data); return 1; } h = (h + 1) % MAX_TABLE; } return 0;} int add(const char *key, char *data){ unsigned long h = hash(key); while (tb[h].key[0] != 0) { if (strcmp(tb[h].key, key) == 0) { return 0; } h = (h + 1) % MAX_TABLE; } strcpy(tb[h].key, key); strcpy(tb[h].data, data); return 1;} int main(int argc, char* argv[]){ int T, N, Q; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { memset(tb, 0, sizeof(tb)); scanf(\"%d\", &amp;N); char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; for (int i = 0; i &lt; N; i++) { scanf(\"%s %s\\n\", &amp;k, &amp;d); add(k, d); } printf(\"#%d\\n\", test_case); scanf(\"%d\", &amp;Q); for (int i = 0; i &lt; Q; i++) { char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; scanf(\"%s\\n\", &amp;k); if (find(k, d)) { printf(\"%s\\n\", d); } else { printf(\"not find\\n\"); } } } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/25/Data-Structure-Hash/"},{"title":"자료구조 | 스택 (Stack)","text":"Data Structure : Stack(스택) 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조(LIFO - Last In First Out)로 데이터를 저장하는 형식을 말합니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Stack에 넣은 후 하나씩 꺼내 화면에 출력하시오. 입력 출력 2 // 테스트 케이스 수 5 // 데이터 크기 1 2 3 4 5 5 5 4 2 3 1 #1 5 4 3 2 1 #2 1 3 2 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Scanner; class Solution { static final int MAX_N = 100; static int top; static int stack[] = new int[MAX_N]; static void stackInit() { top = 0; } static boolean stackIsEmpty() { return (top == 0); } static boolean stackIsFull() { return (top == MAX_N); } static boolean stackPush(int value) { if (stackIsFull()) { System.out.println(\"stack overflow!\"); return false; } stack[top] = value; top++; return true; } static Integer stackPop() { if (top == 0) { System.out.println(\"stack is empty!\"); return null; } top--; Integer value = new Integer(stack[top]); return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); stackInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); stackPush(value); } System.out.print(\"#\" + test_case + \" \"); while (!stackIsEmpty()) { Integer value = stackPop(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt; #define MAX_N 100 int top;int stack[MAX_N]; void stackInit(void){ top = 0;} int stackIsEmpty(void){ return (top == 0);} int stackIsFull(void){ return (top == MAX_N);} int stackPush(int value){ if (stackIsFull()) { printf(\"stack overflow!\"); return 0; } stack[top] = value; top++; return 1;} int stackPop(int *value){ if (top == 0) { printf(\"stack is empty!\"); return 0; } top--; *value = stack[top]; return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); stackInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); stackPush(value); } printf(\"#%d \", test_case); while (!stackIsEmpty()) { int value; if (stackPop(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/21/Data-Structure-Stack/"},{"title":"자료구조 | 트리 (Tree)","text":"Data Structure : Tree(트리) 트리 구조란 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조입니다. 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리(Tree)라고 부릅니다. 예시문제 주어진 입력 값으로 트리를 구성하고, 구성된 트리를 전위순회하고 방문한 노드의 번호를 출력하시오. 첫 줄에는 전체 테스트 케이스의 수(T), 두 번째 줄에는 노드의 총 수(nodeNum), 간선의 총 수(edgeNum)가 주어진다. 그 다음 줄에는 간선이 나열 된다. 간선은 그것을 이루는 두 정점으로 표기된다. 간선은 항상 “부모 자식” 순서로 표기 된다. 예를 들어 “1 2”는 정점 1과 2를 잇는 간선을 의미하며 1이 부모 2가 자식을 의미한다. 부모는 최대 2개의 자식 노드를 갖으며, 최대 노드의 개수는 10000개이다. 입력 출력 2 // Testcase 수 13 12 // N: 노드의 총 수, E: 간선의 총 수 1 2 1 3 2 4 3 5 3 6 4 7 7 12 5 9 5 8 6 11 6 10 11 13 // 간선 정보 (“부모 자식” 순서) 10 9 1 2 1 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 #1 1 2 4 7 12 3 5 9 8 6 11 13 10 #2 1 2 3 4 5 6 7 8 9 10 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.Scanner; class Tree { static final int MAX_CHILD_NUM = 2; class TreeNode { int parent; int []child = new int[MAX_CHILD_NUM]; public TreeNode(int parent) { this.parent = parent; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { child[i] = -1; } } } TreeNode []treenode; int nodeNum; public Tree(int nodeNum) { this.nodeNum = nodeNum; treenode = new TreeNode[nodeNum+1]; for (int i = 0; i &lt;= nodeNum; i++) { treenode[i] = new TreeNode(-1); } } public void addChild(int parent, int child) { int found = -1; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { if (treenode[parent].child[i] == -1) { found = i; break; } } if (found == -1) return; treenode[parent].child[found] = child; treenode[child].parent = parent; } public int getRoot() { for (int i = 1; i &lt; nodeNum; i++) { if (treenode[i].parent == -1) { return i; } } return -1; } public void preOrder(int root) { System.out.printf(\"%d \", root); for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { int child = treenode[root].child[i]; if (child != -1) { preOrder(child); } } }} class Solution { public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int node = sc.nextInt(); int edge = sc.nextInt(); Tree tree = new Tree(node); for (int i = 0; i &lt; edge; i++) { int parent = sc.nextInt(); int child = sc.nextInt(); tree.addChild(parent, child); } int root = tree.getRoot(); System.out.printf(\"#%d \", test_case); tree.preOrder(root); System.out.printf(\"\\n\"); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt; #define MAX_NODE_NUM 10000#define MAX_CHILD_NUM 2 typedef struct{ int parent; int child[MAX_CHILD_NUM];} TreeNode;TreeNode tree[MAX_NODE_NUM];int nodeNum;int edgeNum;int root; void initTree(void) { int i; int j; for (i = 0; i &lt;= nodeNum; i++) { tree[i].parent = -1; for (j = 0; j &lt; MAX_CHILD_NUM; j++) { tree[i].child[j] = -1; } }} void addChild(int parent, int child) { int i; for (i = 0; i &lt; MAX_CHILD_NUM; i++) { if (tree[parent].child[i] == -1) { break; } } tree[parent].child[i] = child; tree[child].parent = parent;} int getRoot(void) { int i; int j; for (i = 1; i &lt;= nodeNum; i++) { if (tree[i].parent == -1) { return i; } } return -1;} void preOrder(int root) { int i; int child; printf(\"%d \", root); for (i = 0; i &lt; MAX_CHILD_NUM; i++) { child = tree[root].child[i]; if (child != -1) { preOrder(child); } }} int main(void){ int test_case; int T; int i; int parent; int child; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d %d\", &amp;nodeNum, &amp;edgeNum); initTree(); for (i = 0; i &lt; edgeNum; i++) { scanf(\"%d %d\", &amp;parent, &amp;child); addChild(parent, child); } root = getRoot(); printf(\"#%d \", test_case); preOrder(root); printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/26/Data-Structure-Tree/"},{"title":"자료구조 | 그래프 (Graph)","text":"Data Structure : Graph(그래프) 그래프(Graph)는 컴퓨터 시스템에서 연결되어 있는 객체간의 관계를 표현할 수 있는 자료구조입니다. 예시문제 첫째 줄에는 V와 E의 갯수, 정점의 정보를 묻는 쿼리의 갯수가 주어지고 둘째 줄부터 간선의 정보(연결된 정점의 번호쌍)가 주어진다. 그 다음 줄에는 정점의 인접정점들이 무엇인지 묻는 쿼리가 정점번호로 주어진다. 정점의 번호는 0~V-1까지 이며, 간선정보는 오름차순으로 나열되어 주어진다. 또한 중복 간선은 존재하지 않는다. 입력으로 주어지는 쿼리의 정점에 인접한 정점들을 각 줄에 출력하라. (2&lt;=V&lt;=100, 1&lt;=E&lt;=1000) 입력 출력 2 6 7 3 // 정점갯수, 간선갯수 쿼리(질문)갯수 0 1 // 간선정보 0 - 1 0 2 0 3 1 2 1 4 3 4 4 5 0 // 쿼리(질문): 정점 번호 2 4 9 10 3 0 1 0 2 0 6 1 3 1 4 1 7 2 4 4 5 6 7 7 8 0 1 7 #1 1 2 3 // 정점0에 인접한 정점리스트 0 1 // 정점2에 인접한 정점리스트 1 3 5 // 정점4에 인접한 정점리스트 #2 1 2 6 0 3 4 7 1 6 8 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.Scanner; class Graph{ class AdjlistNode { int vertex; AdjlistNode next; public AdjlistNode(int v) { vertex = v; next = null; } } class AdjList { int num_members; AdjlistNode head; AdjlistNode tail; public AdjList() { num_members = 0; head = tail = null; } } int num_vertices; AdjList []adjListArr; public Graph(int n) { num_vertices = n; adjListArr = new AdjList[n]; for (int i = 0; i &lt; n; i++) { adjListArr[i] = new AdjList(); } } void addEdge(int src, int dest) { AdjlistNode newNode = new AdjlistNode(dest); if (adjListArr[src].tail != null) { adjListArr[src].tail.next = newNode; adjListArr[src].tail = newNode; } else { adjListArr[src].head = adjListArr[src].tail = newNode; } adjListArr[src].num_members++; newNode = new AdjlistNode(src); if (adjListArr[dest].tail != null) { adjListArr[dest].tail.next = newNode; adjListArr[dest].tail = newNode; } else { adjListArr[dest].head = adjListArr[dest].tail = newNode; } adjListArr[dest].num_members++; } void display(int i) { AdjlistNode adjList = adjListArr[i].head; while (adjList != null) { System.out.printf(\"%d \", adjList.vertex); adjList = adjList.next; } System.out.printf(\"\\n\"); }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int V = sc.nextInt(); int E = sc.nextInt(); int Q = sc.nextInt(); Graph graph = new Graph(V); for (int i = 0; i &lt; E; i++) { int sv = sc.nextInt(); int ev = sc.nextInt(); graph.addEdge(sv, ev); } System.out.printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { int sv = sc.nextInt(); graph.display(sv); } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;malloc.h&gt; typedef struct adjlistNode{ int vertex; adjlistNode *next;} AdjlistNode; typedef struct{ int num_members; AdjlistNode *head; AdjlistNode *tail;} AdjList; typedef struct{ int num_vertices; AdjList * adjListArr;} Graph; AdjlistNode * createNode(int v){ AdjlistNode * newNode = (AdjlistNode *)malloc(sizeof(AdjlistNode)); newNode-&gt;vertex = v; newNode-&gt;next = NULL; return newNode;} Graph * createGraph(int n){ Graph * graph = (Graph *)malloc(sizeof(Graph)); graph-&gt;num_vertices = n; graph-&gt;adjListArr = (AdjList *)malloc(n * sizeof(AdjList)); for (int i = 0; i &lt; n; i++) { graph-&gt;adjListArr[i].head = graph-&gt;adjListArr[i].tail = NULL; graph-&gt;adjListArr[i].num_members = 0; } return graph;} void destroyGraph(Graph * graph){ if (graph) { if (graph-&gt;adjListArr) { for (int v = 0; v &lt; graph-&gt;num_vertices; v++) { AdjlistNode * adjListPtr = graph-&gt;adjListArr[v].head; while (adjListPtr) { AdjlistNode * tmp = adjListPtr; adjListPtr = adjListPtr-&gt;next; free(tmp); } } free(graph-&gt;adjListArr); } free(graph); }} void addEdge(Graph *graph, int src, int dest){ AdjlistNode * newNode = createNode(dest); if (graph-&gt;adjListArr[src].tail != NULL) { graph-&gt;adjListArr[src].tail-&gt;next = newNode; graph-&gt;adjListArr[src].tail = newNode; } else { graph-&gt;adjListArr[src].head = graph-&gt;adjListArr[src].tail = newNode; } graph-&gt;adjListArr[src].num_members++; newNode = createNode(src); if (graph-&gt;adjListArr[dest].tail != NULL) { graph-&gt;adjListArr[dest].tail-&gt;next = newNode; graph-&gt;adjListArr[dest].tail = newNode; } else { graph-&gt;adjListArr[dest].head = graph-&gt;adjListArr[dest].tail = newNode; } graph-&gt;adjListArr[dest].num_members++;} void displayGraph(Graph * graph, int i){ AdjlistNode * adjListPtr = graph-&gt;adjListArr[i].head; while (adjListPtr) { printf(\"%d \", adjListPtr-&gt;vertex); adjListPtr = adjListPtr-&gt;next; } printf(\"\\n\");} int main(int argc, char* argv[]){ int T, V, E, Q, sv, ev; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d %d %d\", &amp;V, &amp;E, &amp;Q); Graph * graph = createGraph(V); for (int i = 0; i &lt; E; i++) { scanf(\"%d %d\", &amp;sv, &amp;ev); addEdge(graph, sv, ev); } printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { scanf(\"%d\", &amp;sv); displayGraph(graph, sv); } } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/27/Data-Structure-Graph/"},{"title":"자료구조 | 연결리스트 (Linked List)","text":"Data Structure : Linked List(연결리스트) 연결리스트(Linked List)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로, 데이터를 저장하는 자료 구조입니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Linked List에 넣은 후, 2개의 간격으로 하나씩 데이터를 뺄 때 마지막에 남아 있는 데이터를 출력하시오. Ex) 1 2 3 4 5 -&gt; 2 3 4 5 -&gt; 2 3 5 -&gt; 2 5 -&gt; 2 입력 출력 2 //테스트 케이스 수 5 //입력 수 1 2 3 4 5 //입력 데이터 6 1 2 3 4 5 6 #1 2 #2 5 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.Scanner; class ListNode { int data; ListNode prev; ListNode next; public ListNode() { data = 0; prev = this; next = this; } public static ListNode appendListNode(ListNode head, int data) { ListNode node = new ListNode(); node.data = data; if (head == null) { head = node; } else { ListNode last = head.prev; last.next = node; head.prev = node; node.prev = last; node.next = head; } return head; } public static ListNode removeListNode(ListNode head, ListNode node) { if (head == head.next) { return null; } else { ListNode prevNode = node.prev; ListNode nextNode = node.next; prevNode.next = nextNode; nextNode.prev = prevNode; return (head == node) ? nextNode : head; } }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { ListNode head = null; int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { int data = sc.nextInt(); head = ListNode.appendListNode(head, data); } ListNode node = head; while(head != head.next) { ListNode nextNode = node.next; head = ListNode.removeListNode(head, node); node = nextNode.next.next; } System.out.printf(\"#%d %d\\n\", test_case, head.data); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt; #define MAX_NODE 100 typedef struct listNode{ int data; struct listNode* prev; struct listNode* next;} ListNode; typedef struct{ int use; ListNode node;} ListNodeHeap; ListNodeHeap heap[MAX_NODE]; void initHeap(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { heap[i].use = 0; }} void initListNode(ListNode* node){ node-&gt;data = 0; node-&gt;prev = node; node-&gt;next = node;} ListNode* getListNode(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { if (!heap[i].use) { heap[i].use = 1; initListNode(&amp;heap[i].node); return &amp;heap[i].node; } } return NULL;} void destroyListNode(ListNode* node){ ListNodeHeap* heap_node = (ListNodeHeap*)((int*)node - 1); heap_node-&gt;use = 0;} ListNode* appendListNode(ListNode* list, int data){ ListNode* node = getListNode(); node-&gt;data = data; if (list == NULL) { return node; } else { ListNode* last = list-&gt;prev; last-&gt;next = node; list-&gt;prev = node; node-&gt;prev = last; node-&gt;next = list; return list; }} ListNode* removeListNode(ListNode* list, ListNode* node){ if (list == list-&gt;next) { destroyListNode(node); return NULL; } else { ListNode* prev = node-&gt;prev; ListNode* next = node-&gt;next; prev-&gt;next = next; next-&gt;prev = prev; destroyListNode(node); return (list == node) ? next : list; }} int main(int argc, char* argv[]){ int T, N; setbuf(stdout, NULL); scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; ++test_case) { ListNode* list = NULL; ListNode* node; int i; initHeap(); scanf(\"%d\", &amp;N); for (i = 0; i &lt; N; i++) { int data; scanf(\"%d\", &amp;data); list = appendListNode(list, data); } node = list; while (list != list-&gt;next) { ListNode* nextNode = node-&gt;next; list = removeListNode(list, node); node = nextNode-&gt;next-&gt;next; } printf(\"#%d %d\\n\", test_case, list-&gt;data); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/28/Data-Structure-Linked-List/"},{"title":"Hexo | 찬미의 개발블로그 - 시작을 여는 글","text":"안녕하세요, 찬미의 개발블로그입니다. 소소하게 IT 블로거로 활동하다 잠시 접었는데, 개발과 함께 블로그도 다시 시작합니다. Git Blog는 Jekyll로 처음 시작했지만, 우여곡절 끝에 Hexo로 만든 개발블로그로 다시 인사드립니다. 🔮 Git Blog에 매력을 느끼다 저는 살면서 지금까지 소소하게 취미를 나누는 블로그나 IT 블로그를 운영해보았고, “개발”이라는 명확한 주제 하나로 블로그를 시작하기는 처음입니다. 그동안 네이버 블로그와 같이 플랫폼에서 제공된 블로그만을 사용해왔는데, 우연히 Git Blog를 접하게 되면서 개발자로서 잡덕후의 길에 빠지고 말았습니다. 그때 접했던 블로그는 김정헌 님의 프로그래밍으로 예술을 꿈꾼다 라는 블로그였는데 제게는 너무 신선한 충격으로 다가와서 Git Blog를 처음 접하는 계기가 되었습니다. 너무나 제 취향으로 커스텀이 잘 되어있는 블로그였습니다. 링크를 타고 들어가 보시면 저와 같은 감정을 느끼실지도 모르겠습니다. 저도 카카오 기술블로그나 우아한형제 기술블로그의 깔끔한 UI가 마음에 들었는데 Git Blog이라는 것을 알고 나서는 제가 원하는 템플릿과 폴더 구조로 블로그를 시작하고 싶었습니다. 🏓 Hexo로 Devlog 시작 Jekyll, Hexo, Gatsby, Hubgo 등 Github Page를 활용하여 만들 수 있는 블로그 프레임워크의 종류는 다양합니다. Git으로 개발블로그나 기술블로그를 만들어봐야겠다고 다짐한 뒤, 참고문헌이 많고 사용자층이 두꺼운 Jekyll을 시작했습니다. 그동안 이것저것 건드려보면서 커스텀 하느라 한 달 동안 참 많이 헤매었습니다. 제가 만들고 싶은 블로그도 찾아보았고, 제작자분께 컨택 메일도 드려보았습니다. 그러나 처음 접해본 Ruby와 Liquid를 파악하는데 시간이 많이 소모되었고, 이슈 해결 기록을 남겨놓겠다던 제 바람과는 달리 블로그 제작하는 과정이 산으로 가는 듯했습니다. 그러던 중 Javascript를 공부하면서 Node.js 기반으로 만들어진 Hexo로 옮기게 되었습니다. 굳이 커스텀을 하지 않아도 Hexo에는 더 멋진 테마가 많았습니다. 다만 초보자에겐 접근하기가 매우 어려울 것으로 생각했습니다. 🧶 당면했던 미해결 과제 : 다국어지원 사이트 구축 아쉽게도 다국어지원을 해결하지 못했습니다. Jekyll에는 Jekyll-polyglot이라는 플러그인이 있는데 Windows 환경에만 발생하는 버그 때문에 에러를 해결하지 못했습니다. 어떻게 하면 할 수 있을지 더욱 고민해봐야 할 것 같습니다. Hexo를 시작하면서도 한국어와 영어를 지원하고 싶었으나, 이러다 한 글자도 못 적고 블로그 구축에만 매달릴 것 같아서 먼저 한국어로 시작해보려 합니다. 부득이한 경우 영어는 다른 곳에서 영어 포스팅을 하게 될 수도 있을 것 같습니다. 지금까지 눈여겨봐 둔 곳은 Medium이라는 곳이지만 현재 블로그에 먼저 충실히 하고자 합니다. 📄 블로그 운영 계획 고생 끝에 낙이 온다고 드디어 블로그 하나 생성하여 운영하게 되니 뿌듯합니다. 10번도 넘게 생성했다 제거했다 반복하면서 Hexo 블로그를 구축하는 방법을 한 줄 한 줄 기록해두었습니다. Hexo 블로그 구축 방법에 대해서는 차차 포스트를 할 생각입니다. 물론, 이 블로그도 아직 손을 볼 곳들이 많습니다. 실명으로 만들어진 블로그라 더더욱 신경을 쓰게 되는 것은 어쩔 수 없나 봅니다. 저 같은 초보자가 제 블로그를 본다면 도움이 되었으면 합니다. 개발을 모르는 사람이 읽어도 이해되는 블로그로 만들고 싶습니다. 특히나 구글링하다 보면 Git Blog를 많이 접해볼 수 있는데, 원리를 이해하기 전까지는 진입장벽이 높은 편이라 그 벽을 낮추고 싶다는 생각마저 하게 되었습니다. 현재 알고리즘 공부를 비롯하여 이것저것 공부에, 프로젝트에, 신경을 써야 할 것들이 많지만 그리고 꾸준히 포스팅해보겠습니다. 커스텀은 처음부터 완벽하게 하기 힘들기에 블로그를 운영해가며 천천히 해보려고 합니다. 개발블로그를 운영하면서 이슈해결 과정이나 프로젝트 진행 과정을 꼼꼼히 기록해서 이것도 포스팅할 수 있도록 해보겠습니다. 구글링하면 웬만한 자료들을 찾을 수 있지만, 찾아보는 것만으로는 그것들이 결코 제 것이 되지는 못합니다. 직접 기록하고 공부하며 제 것으로 만들기 위해 초점을 맞추려고 합니다. 저는 전문가가 되기 위해 노력하지만, 잘못된 내용이나 수정사항이 있을 수 있습니다. Issues나 댓글에 남겨주시면 빠르게 반영하도록 하겠습니다. 잘 부탁드립니다!","link":"/Devlog/Hexo/2019/07/15/Hexo-Beginning-of-devlog/"},{"title":"Hexo | 헥소 개발자 커뮤니티에 초대합니다!","text":"혹시 Hexo 사용자이신가요? Git Blog 혹은 Git Site를 운영하고 계시거나 Hexo에 관심 있다면 이 글을 한 번 주목해주세요! 👩‍👩‍👧‍👧 Hexo를 사용하는 개발자 커뮤니티 👨‍👨‍👦‍👦 Github Page를 통해 Git Blog를 운영할 수 있는데, Hexo, Jekyll, Gatsby, Hugo 등 많은 블로그 프레임워크가 있습니다. 제가 어떻게 Git Blog를 시작하게 되었는지 궁금하신 분들은 Hexo | 찬미의 개발블로그 - 시작을 여는 글를 참고해주세요. 저는 Jekyll을 사용하다 Hexo를 사용하고 있습니다. Hexo가 Jekyll보다 한국어로 된 정보가 적은 편이라 영어와 중국어를 사용해가며 구글링했던 경험이 있네요. 저 혼자 삽질만 하다가 정보공유를 위한 커뮤니티를 하나 만들었습니다. 이 글 맨 아래에 링크를 걸어두었고, 정보공유와 질문, 수다 위주로 진행하고 있어요. 😊 환영해요! 네티켓만 지켜주신다면 자유롭게 이용하실 수 있고, 누구나 환영합니다. 오픈카톡방이라 익명으로 활동하실 수 있어요. Hexo를 사용하는 개발자 커뮤니티 Hexo로 만든 개발블로그나 기술블로그, 웹사이트 모두 환영해요! 개발자 환영! 개발자가 아니어도 Hexo를 사용하시는 분들도 환영! Git Blog 이웃해요~ 👋 오픈카톡방 참여방법 하단의 링크로 들어오셔서 간단한 자기소개 부탁드릴게요! 오픈카톡방 링크 : ★ Hexo:헥소 개발자 커뮤니티","link":"/Devlog/Hexo/2019/11/11/Hexo-Developer-community/"},{"title":"[이슈등록] Java 배열에서 최대값 찾기 구문에러","text":"Error Message: The method max(Collection&lt;? extends T&gt;) in the type Collections is not applicable for the arguments (int[]) 🌰 오류메시지 123456// Error MessageException in thread \"main\" java.lang.Error: Unresolved compilation problem: The method max(Collection&lt;? extends T&gt;) in the type Collections is not applicable for the arguments (int[]) at Main.main(Main.java:28) 💎 문제상황 비타알고 알고리즘 문제를 풀다가 오류가 발생했습니다. C++에서 max_element 사용해서 배열 자체를 최대값을 찾는게 가능한 것 같은데 Java에서는 Math.max로 배열 비교가 안되는 것 같습니다. Java API Document에서도 찾지 못했습니다. 🧩 예시코드 123// Full Code는 추후 업데이트 하도록 하겠습니다.int maxNum = Collections.max(dp); 🔑 해결방안여기서 2가지 궁금증을 가지고 이슈등록을 진행했으며, 해결되는대로 글을 업데이트하겠습니다. 우선, Arrays와 Collections에 대한 기초가 미흡하다고 느껴서 그 부분에 대해 공부를 해봐야겠네요. 1) C++에서 max_element가 Java에서 Math.max랑 같은가? 2) Java로 구현하려면 하나씩 max 일일이 비교해야 되는것인가? 해결되는대로 본문 수정하겠습니다.","link":"/Devlog/Issues/2019/09/25/Issues-Java-Collection-max/"},{"title":"[이슈해결] Java - java.lang.ArrayIndexOutOfBoundsException","text":"Error Message: java.lang.ArrayIndexOutOfBoundsException 🌰 오류메시지 1234// Error MessageException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1 at Main.main(Main.java:12) 💎 문제상황 지원 회사의 온라인 코딩테스트에 응시하다가 에러가 발생했습니다. 해당 에러는 최근에 제가 자주 접했던 에러입니다. 아래 코드의 의도는 개행문자 단위로 한 번에 입력을 받아 처리하고, 문자열과 숫자를 따로 분리하려고 했습니다. String[] input = br.readLine().split(&quot;\\\\n&quot;);에서 Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException에러가 발생했고, 이를 처리하기 위해 알아보았습니다. 🧩 예시코드 12345678910111213141516// Wrong Code : Error가 발생한 Full Code입니다.import java.io.*;class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); String[] input = br.readLine().split(\"\\\\n\"); // Error int x = 0; for (int i=0; i&lt;n; i++) { String command = input[i].split(\" \")[0]; x = Integer.parseInt(input[i].split(\" \")[1]); } }} 예시 입력값] 12enqueue 1enqueue 2enqueue 2enqueue 1enqueue 2dequeuedequeuedequeuedequeuedequeueenqueue 7dequeue 🔑 해결방안 예시 입력값을 보시면 dequeue와 enqueue가 번갈아 나옵니다. String[] input에서 한 번에 입력받지 않고, for문을 사용하여 한 줄씩 입력받는 방식으로 변경하여 에러를 해결했습니다. 1234567891011121314151617// Right Code : Error를 해결한 Full Code입니다.import java.io.*;class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); // String[] input = br.readLine().split(\"\\\\n\"); // Error int x = 0; for (int i=0; i&lt;n; i++) { String input = br.readLine(); // Solving String command = input[i].split(\" \")[0]; x = Integer.parseInt(input[i].split(\" \")[1]); } }} 위의 코드에서 Error가 발생했던 입력문을 Solving 부분으로 바꿔주어 에러를 해결할 수 있었습니다. 해당 이슈에서는 ArrayIndexOutOfBoundsException 에러가 난 이유가 br.readLine()에 이미 강제개행이 포함이 되어 있어, 없는 문자에 접근하는 것으로 이해했습니다. 개행문자 단위로 입력을 받을 경우, 위의 내용처럼 입력을 받는 것이 낫다는 것을 알게 되었습니다.","link":"/Devlog/Issues/2019/09/29/Issues-Java-java.lang.ArrayIndexOutOfBoundsException/"},{"title":"[이슈해결] Git & Expo-CLI - Input is required, but Expo CLI is in non-interactive mode.","text":"Error Message: Input is required, but Expo CLI is in non-interactive mode. 🌰 오류메시지 12[17:52:12] Input is required, but Expo CLI is in non-interactive mode.--template: argument is required in non-interactive mode. Valid choices are: &apos;blank&apos;, &apos;blank (TypeScript)&apos;, &apos;tabs&apos;, &apos;minimal&apos;, &apos;minimal (TypeScript)&apos; or any custom template (name of npm package). 💎 문제상황 토이프로젝트로 진행중인 Kawai Todo App with React Native를 위해 expo를 사용하려고 했습니다. expo-cli 설치를 하기위해 Git Bash에서 npm install expo-cli --global 입력 후, new project를 생성하기 위해 expo init Kawai-Todo을 입력했더니 Input is required, but Expo CLI is in non-interactive mode.라는 에러메시지가 발생했습니다. 🧩 예시코드 Wrong Code : Git Bash에서 입력 후 Error가 발생한 명령어입니다. 1$ expo init Kawai-Todo 🔑 해결방안 1) Git Bash에서 사용했던 명령어를 cmd에서 입력했더니 다음 단계로 잘 넘어가집니다. Right Code : cmd에서 Error를 해결한 명령어입니다. 기존 명령어와 같습니다. 1$ expo init Kawai-Todo 2) 하단의 내용에서 방향키를 이용하여 원하는 항목을 선택하고 엔터키를 입력합니다. 12345678? Choose a template: (Use arrow keys) ----- Managed workflow -----&gt; blank a minimal app as clean as an empty canvas blank (TypeScript) same as blank but with TypeScript configuration tabs several example screens and tabs using react-navigation ----- Bare workflow ----- minimal bare and minimal, just the essentials to get you started minimal (TypeScript) same as minimal but with TypeScript configuration 3) https://docs.expo.io/versions/latest/workflow/configuration/ 에 접속하여 참고하고, 앱 설정에 맞게 설정해줍니다. 하단의 메시지에서 방향키를 이용하여 해당 URL 부분 중 name으로 이동하고, 앱의 Home Screen에 들어갈 이름을 입력합니다. 123456789? Choose a template: expo-template-blank? Please enter a few initial configuration values. Read more: https://docs.expo.io/versions/latest/workflow/configuration/ » 50% completed { &quot;expo&quot;: { &quot;name&quot;: &quot;&lt;The name of your app visible on the home screen&gt;&quot;, &quot;slug&quot;: &quot;Kawai-Todo&quot; } } 4) 다음과 같이 100%로 바뀌었다면 앱 설정이 완료되었습니다. 123456789? Choose a template: expo-template-blank? Please enter a few initial configuration values. Read more: https://docs.expo.io/versions/latest/workflow/configuration/ » 100% completed { &quot;expo&quot;: { &quot;name&quot;: &quot;Kawai Todo&quot;, &quot;slug&quot;: &quot;Kawai-Todo&quot; } } 5) 엔터키를 누르면 다음 메시지가 나타나면서 Expo 설치를 시작합니다. 123456√ Please enter a few initial configuration values. Read more: https://docs.expo.io/versions/latest/workflow/configuration/ · 100% completedExtracting project files...Customizing project...Initialized a git repository.Installing dependencies... 6) 설치가 완료되었습니다. 12345678910111213141516171819202122232425262728npm WARN deprecated deep-assign@3.0.0: Check out `lodash.merge` or `merge-options` instead.npm WARN deprecated core-js@1.2.7: core-js@&lt;2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.&gt; core-js@2.6.9 postinstall C:\\Users\\kimcm\\Kawai-Todo\\node_modules\\metro-babel-register\\node_modules\\core-js&gt; node scripts/postinstall || echo &quot;ignore&quot;Thank you for using core-js ( https://github.com/zloirock/core-js ) for polyfilling JavaScript standard library!The project needs your help! Please consider supporting of core-js on Open Collective or Patreon:&gt; https://opencollective.com/core-js&gt; https://www.patreon.com/zloirockAlso, the author of core-js ( https://github.com/zloirock ) is looking for a good job -)npm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})added 783 packages from 427 contributors and audited 37575 packages in 120.979sfound 11 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for detailsYour project is ready at C:\\Users\\kimcm\\Kawai-TodoTo get started, you can type: cd Kawai-Todo npm start 🎀 후기 가끔 어떤 명령어는 Git Bash에서 실행이 되지 않을 때가 있습니다. 그럴 때는 cmd에서 한 번 입력해보면 잘 작동되는 경우가 있습니다. Warn 메시지가 수반되는 경우가 있는데, 오류메시지를 해결하기 위해 구글링해보면 Mac OS에서 발견한 적이 없습니다. Windows 환경에서 작업하고 있기 때문일 것이라는 생각이 듭니다. Expo XDE를 사용할 수 있다는 점에서 Mac OS를 쓰고 싶다는 생각이 강력히 드는 Error Message였습니다.","link":"/Devlog/Issues/2019/10/06/Issues-Git-Expo-CLI-is-in-non-interactive-mode/"},{"title":"[이슈등록] Git & Hexo - LF will be replaced by CRLF","text":"Error Message: LF will be replaced by CRLF 🌰 오류메시지 12345// Error Messagewarning: LF will be replaced by CRLF in About/index.html.The file will have its original line endings in your working directory 💎 문제상황 Node.js 기반 정적 사이트 생성기인 Hexo를 사용하여 블로그를 운영하면서 자주 보았던 오류메시지입니다. Git Bash에서 hexo deploy 명령어를 입력하면 뜹니다. 구동에는 문제가 없어서 무시하고 넘어갔었지만, 포스트가 많아짐에 따라 포스트 개수만큼 에러메시지도 함께 늘어나고 있습니다. 한 번 해결했던 것 같은데 완전히 해결이 되지 않아 다시 이슈 등록합니다. 진행상황2019.10.06 이슈등록 2019.11.10 Window 환경에서는 CRLF를, Linux/Max 환경에서는 LF가 적용됩니다. 구글링을 통해 해결할 수 있는 방법을 찾았으나, 원인은 다른 데 있는 듯 합니다. (참고사이트)","link":"/Devlog/Issues/2019/10/06/Issues-Git-Hexo-LF-will-be-replaced-by-CRLF/"},{"title":"NHN 2019 하반기 기술부문 신입사원 공개채용 설명회 후기","text":"지난 9월 10일, 캐치카페 한양대에서 \"NHN 2019 하반기 기술부문 신입사원 공개채용 설명회\"가 있었습니다. 1부에는 멘토링을 진행했고 2부에는 채용설명회를 진행했었는데요, Q&A에 나온 질의응답 일부분을 정리해보았습니다. 1부에는 빙 둘러서 앉아있었는데요, 1~5시 사이에 1시간 간격으로 질의응답 시간이 있었습니다. 인사담당자 한 분과 현직자 두 분과 함께 했습니다. 세 분이 번갈아가며 질의응답을 해주셨습니다. 1부 멘토링 : 질의응답 Q1. 개발자 인재상 A1. 개발자 인재상이 없는 이유는 특정지을 수 없기 때문입니다. 지원자의 성격과 특징을 봅니다. Q2. 코딩테스트는 어떻게 진행되는지? Q2. 언어는 C, C++, Java만 지원되며, 2시간동안 온라인으로 진행됩니다. Q3. Feel the TOAST 때 무엇을 하는지? A3. 오전 동안 1문제를 풀게 되며 라이브 코딩으로 진행됩니다. 오후에는 기술면접으로 손코딩을 합니다. Q4. 전산학 기초는 어떻게 공부해야 하는지? A4. 대학생 때 보던 전공책이나 수업용 PPT, 정보처리기사 등 자주 출제되는 문제 위주로 공부하면 됩니다. 학생 때 중간, 기말고사에 나왔던 문제들 위주로요. Q5. 자기소개서 쓰는 꿀팁이 있다면? A5. 자기소개서는 서류전형 때 타 기업 이름을 썼는지, 임시저장을 위해 무의미한 문자열을 입력해두었는지 등 먼저 확인하고 1번만 확인한다고 하십니다. 최종면접 때 자기소개서에서 질문이 나올 수도, 나오지 않을 수도 있습니다. (저는 타 기업과는 다르게 인사담당자님께서 참 솔직하다는 인상을 받았네요.) Q6. 어떤 개발환경, 어떤 언어를 사용하는지? A6. 팀마다 다르겠지만 서버개발은 Java, Spring을 사용하기도 하고 FE 개발은 Vue를 사용하기도 합니다. Q7. 채용인원은 어떻게 되는지? A7. 인원을 정해두지는 않습니다. 올해는 사업확장이 활발하므로 채용 규모가 작년과 비슷할 것으로 예상됩니다. Q8. SW지식 테스트는 어떤 형태로 문제가 출제되는지? A8. 객관식, 단답형, 서술형 등 다양하게 있으며, 아주 잠깐이지만 캐치에서 만든 영상에 문제가 나옵니다. 2부 채용설명회 채용설명회는 위의 사진입니다. 위 선물과 비어파티가 함께 진행되었습니다. 전 아쉽게도 개인사정으로 맥주는 못 마셨지만 ^^; 나중에 NHN에 입사한다면 노트북에 잔뜩 붙이고 싶은 귀여운 스티커들입니다. 2019년 9월 17일 오후 2시까지 지원서 마감이니 얼른 지원해야겠네요.","link":"/Devlog/Review/2019/09/16/Review-NHN-2019-Technical-Division-Public-Recruitment-Session/"},{"title":"Java | 헷갈리기 쉬운 Java 개념 #01 배열","text":"헷갈리기 쉬운 Java 개념 중 배열에 대해 다루어, 간략히 정리했습니다.Java 언어에 대한 기본적인 지식이 있어야 이해할 수 있는 포스트입니다. 1. 1차원 배열 선언하는 방법 12345678// 방법1int[] arr1 = new int[5];// 방법2int[] arr2 = {1, 2, 3, 4, 5};// 방법3int[] arr3 = new int[]{1, 2, 3, 4, 5}; 2. 배열 한 번에 출력하는 방법 123456789int[] arr = {1, 2, 3, 4, 5};// 방법1for (int i=0; i&lt;5; i++) { System.out.println(arr[i]);}// 방법2System.out.println(Arrays.toString(arr)); 3. 배열 복사하는 방법 1234int[] arr = {1, 2, 3, 4, 5};int[] arrCopy = new int[5];System.arraycopy(arr, 0, arrCopy, 0, 5); System.arraycopy(원본 배열, 시작인덱스, 목적지 배열, 시작인덱스, 개수)를 사용하면 됩니다. 4. ‘==’과 ‘equals’의 차이점 1234// new 연산자로 객체를 생성하면 a와 b의 주소값이 달라집니다.String a = new String(\"123\")String b = new String(\"123\") ==는 주소값만을 비교하지만, equals는 주소값과 문자열 내용을 비교합니다. 5. Char에서 String으로 변환, String에서 Char로 변환 12String str = new String(arr); // char에서 string으로char[] tmp = str.toCharArray(); // string에서 char로 6. 2차원 배열(다차원 배열) 선언하는 방법 1int[][] arr = new int[][]{{1,2,3}, {4,5,6}};","link":"/Language/Java/2019/10/03/Java-Easily-confused-Java-concepts-Arrays/"},{"title":"운영체제 | #01 운영체제 소개","text":"1. 운영체제 소개(1) 개요운영체제란? 컴퓨터 하드웨어와 컴퓨터 사용자 간의 매개체 역할을 하는 시스템 소프트웨어 컴퓨터 자원을 통제하고 할당하는 공통 기능을 컴퓨터웨어 소프트웨어 하나로 통합한 것 커널(Kernel) 운영체제의 핵심으로 메모리에 상주하며 운영체제의 다른 부분 또는 응용 프로그램 수행에 필요한 환경을 설정하는 소프트웨어 목적 컴퓨터 시스템을 편리하게 이용 컴퓨터 하드웨어를 효율적으로 관리 컴퓨터 자원 관리 측면에서의 운영체제의 역할 조정자 운영체제는 시스템을 운영하여 여러 운영 요소(하드웨어, 소프트웨어(프로그램), 데이터)를 적절하게 사용할 수 있도록 제어 자원 할당자 또는 관리자 컴퓨터 시스템이 문제를 해결하는 데 필요한 자원(프로세서 시간, 메모리 공간, 파일 저장 공간, 입출력장치 등)을 할당하는 업무 입출력장치와 사용자 프로그램 제어 컴퓨터 시스템의 부적절한 사용이나 오류를 방지하기 위해 사용자 프로그램의 실행의 제어 입출력장치를 동작시키고 통제하는 역할 컴퓨터 시스템 구성요소와 운영체제 (2) 운영체제의 역할과 목적운영체제의 목적 운영체제는 두 가지 주요 목적을 달성하기 위해 발전 편리성 : 사용자가 프로그램을 개발하고 사용하는 데 좀 더 편리한 환경 제공 효율성 : 자원을 효과적으로 사용하기 위해 각 프로그램을 유기적으로 결합하여 시스템 전체 성능을 향상시키는 방향으로 설계 처리능력 : 시스템의 생산성을 나타내는 대표 지표로 단위 시간당 처리하는 작업량 신뢰도 : 하드웨어(펌웨어), 소프트웨어가 실패 없이 주어진 기능을 수행할 수 있는 능력 응답시간 : 사용자가 시스템에 작업을 의뢰한 후 반응을 얻을 때까지의 시간 (시분할 방식 시스템과 온라인 시스템에서 사용하는 용어, 일괄 처리 시스템에서는 Turn Around Time) 사용가능도(가동률) : 사용자가 일정 기간 동안 컴퓨터를 실제로 사용한 시간(비율) (3) 운영체제의 유형일괄 처리 시스템(batch processing system) 유휴 상태의 시간을 없애기 위하여 작업 순서의 자동화(automatic job sequencing) 개념이 도입 상주 모니터(resident monitor)를 수행 작업의 준비 및 실행 순서를 자동화함으로써 시스템의 성능을 증진 다중 프로그래밍 시스템(multi programming system) 중앙처리장치가 항상 수행되도록 하여 그 이용도를 높이기 위한 방안 주기억장치 내에 여러 프로그램들이 존재하도록 시분할 시스템(time-sharing system) 여러 사용자들이 컴퓨터 자원에 대한 짧은 시간 단위의 공유(sharing) 사용자는 대화식(interactive) 단말장치를 이용하여 시분할 시스템과 인터페이스를 수행 실시간시스템(real-time system) 매우 엄격하게 정의되어 있는 시간 제약 등과 같은 사건들의 제시된 상황을 분석 사전에 정의된 제약 내에서 수행되어야 함 다중 처리 시스템(multiprocessing system) 밀착된 결합(tightly coupled) 시스템 혹은 강결합 시스템라고도 함 병렬 시스템(parallel system)이라고도 함 공유기억장치(common memory)를 통하여 하나로 연결된 다중 처리기(multi-processor)의 제어 및 공유를 위한 시스템 개인용 컴퓨터 시스템 중앙처리장치와 주변장치 이용률을 최대화시키려는 노력 대신에 편리성과 응답성을 더 중요시 함 분산처리 시스템(distributed processing system) 느슨한 결합(loosely coupled) 시스템이라고도 함. 프로세서들이 기억장치와 클럭을 공유하지 않으며 각 프로세서들은 자신의 지역(local) 기억장치 보유 프로세서들은 고속의 버스(bus)나 전화선과 같은 다양한 통신 라인을 통해 서로 통신 자원을 가지고 있는 사이트는 서버(server)가 되며, 반면 다른 사이트에서의 클라이언트(client)나 사용자는 그 자원을 사용 멀티미디어 시스템(multimedia system) 다양한 미디어를 이용하여 멀티미디어 콘텐츠를 제작하기 위해 필요한 하드웨어와 소프트웨어로 구성 멀티미디어 콘텐츠를 제작하기 위한 저작도구(authoring tool)가 필요 임베디드 시스템(embedded system) 정의 마이크로프로세서 또는 마이크로컨트롤러를 내장하여 시스템 제작자가 의도한 몇 가지 혹은 특수한 기능만을 수행하도록 제작된 시스템 임베디드 운영체제의 강점 임베디드 시스템과 그 한정된 자원들의 능력에 맞게 최적화 (4) 운영체제의 발전 과정운영체제의 발전 과정 운영체제와 컴퓨터 구조는 서로 많은 영향을 끼쳤으며, 관찰을 통해 운영체제의 개념을 올바르게 이해할 수 있다. 하드웨어와 같이 “세대”라고 불리는 발전 단계를 거쳤으며, 그 과정은 아래의 표와 같다. (5) 운영체제에 대한 관점자원 관리자 관점 각 자원에 대한 수행 과정 자원의 상태를 추적·저장 어떤 프로세스가 언제 어떤 자원을 얼마나 사용할 것인지를 결정하기 위한 정책 수립 자원의 할당 자원의 회수 프로세스 관리 기능 중앙처리장치와 프로세스(process)의 상태를 추적·저장 프로세스 스케줄러(process scheduler) 기억장치 관리 기능 기억장치의 상태를 추적·저장 장치(device) 관리 기능 채널 등의 제어장치 및 입출력장치와 같은 각종 장치의 상태를 추적·저장 입출력 트래픽 제어기(I/O traffic controller) 입출력 스케줄 링(I/O scheduling) 정보 관리 기능 정보의 위치, 사용 여부 및 상태 등을 추적·관리 파일시 스템(file system)이리고도 함 프로세스 관점 하나의 작업이 제시되어 완료될 때까지 하나의 프로세스에 대하여 그 상태를 변환시키고 관리 [그림1-7] 다중 프로그래밍 시스템에서의 복수 프로세스 계층 구조 관점 자원 관리 루틴이 어떻게 수행되고, 이 루틴들이 상호간에 어디에 논리적으로 위치하는가 모듈화 된 자원 관리 [그림1-8] 계층적 기계 개념의 구성도 (6) 입출력 프로그래밍대부분의 컴퓨터에 있어서 입출력은 중앙처리장치와 비동기적(asynchronous)으로 수행즉, 중앙처리장치와 입출력장치에 대한 작동이 독립적이며, 수행상의 시간관계 규정이 없이 병행적으로 수행BIOS (basic input/output system) ROM에서 얻어낸 정보 부팅된 프로세스를 실행시키는 명령어들을 포함 컴퓨터 칩에 저장된 명령어들을 펌웨어(firmware)라고 함 BIOS를 뛰어넘는 확장성 펌웨어 인터페이스(EFI: extensible firmware interface)가 개발 부트 진행과정(boot process) 컴퓨터 가동을 위해 파워버튼을 누르면 부트 로더가 준비동작에 들어감 POST(Power-On Self-Test) 수행 다른 BIOS들이 해당 준비동작에 들어감. 유저가 원할 경우 BIOS 세팅들에 접근을 위해 즉시 ‘키’ 조작 시도함 잠깐 동안의 메모리 테스트가 수행되고 여러 파라메타들이 세트됨. 플러그와 플레이 디바이스들이 준비동작에 들어감 DMA(Direct Memory Access)채널을 위한 자원들과 IRQ(Interrupt Request)할당됨 부트 디바이스들이 정해지고 준비동작에 들어감 OS가 준비동작에 들어감 POST (power on self test) 성공적인 부팅 및 적정 수행의 확인을 위해 필요하드웨어에 대해 행하는 테스트 수행하는 일 초기BIOS의 완벽한 보전 확인 주기억장치의 할당, 확인 및 그 크기(size)의 결정 시스템 버스(buses)와 시스템디바이스의 할당 및 시작 다른 BIOS들의 시작허용 (비디오 또는 그래픽카드 등) 사용자에게 BIOS시스템 구성 페이지에 접근할 수 있는 권한부여 부트 디바이스 할당 및 부트 파일을 가진 디바이스 찾기 운영체제에 의해 요구되는 그 외 준비관련 태스크들의 마무리 작업의 수행 버퍼링(buffering) 입출력장치의 느린 속도를 보완하는 한 가지 방법 중앙처리장치와 입출력장치 간의 시간적 불균형을 극복 미리 읽혀진 레코드들이 존재하는 곳은 주기억장치의 일부 [그림1-9] 버퍼를 이용한 출력의 예 입출력장치의 느린 속도를 보완하여, 유휴시간이 없도록 프로세서의 연산 과정과 함께 어떤 작업의 입출력을 동시에 수행하는 기능 스풀링(SPOOLing) 디스크(disk)를 매우 큰 버퍼처럼 사용하는 것 채널(channel) 출력장치와 중앙처리장치 사이에 입출력 전담 처리기 [그림1-10] 입출력 채널을 갖는 컴퓨터 시스템 선택 채널(select channel) 여러 개의 입출력장치가 연결되어 있다 하더라도 한 번에 단 하나의 입출력장치만을 선택적으로 지원 비교적 전송 속도가 빠른 입출력장치인 디스크나 CD-ROM 등의 입출력을 제어 멀티플렉서 채널(multiplexer channel) 다수의 저속도 입출력장치가 채널의 단일한 데이터 경로를 공유하면서 데이터를 전송 여러 개의 저속도 입출력장치가 멀티플렉서 채널에 연결되어 시분할(time­sharing) 형태로 제어 키보드나 프린터와 같은 비교적 전송 속도가 느린 입출력장치를 제어 채널과 중앙처리장치 간의 통신은 일반적으로 인터럽트(interrupt) [그림1-11] 다양한 형태의 채널 연결 구조 인터럽트(interrupt) 시스템에 예기치 않은 상황이 발생하였을 때, 그것을 운영체제에 알리기 위한 메커니즘 종류 입출력(I/O) 인터럽트 외부(external) 인터럽트 SVC(SuperVisor Call) 인터럽트 기계 검사(machine check) 인터럽트 프로그램 에러(program error) 인터럽트 재시작(restart) 인터럽트 구조 및 처리 [그림1-12] 인터럽트 처리 과정 [그림1-13] 인터럽트의 처리 과정 및 PSW 위치","link":"/Computer-Science/Operating-System/2019/08/06/Operating-System-introduce/"},{"title":"깃허브 잔디심기 - 6개월간 회고록","text":"오늘은 처음 커밋한 날로부터 255일 되는 날이며, 1일 1커밋을 실천하기로 마음먹은 날로부터 247일째 되는 날이다. 대략 6개월 정도 되었으니 깃허브 잔디심기에 대한 회고록을 적어볼까 한다. 에세이를 작성할 때는 내 생각과 느낌을 적는 글이니, 편하게 적을 예정이다. 참고로 나는 말문이 트이면 굉장히 수다스러운 편이다. 초등학교 5학년 때부터 중학교 2학년까지 매일 하루찾기라는 일기를 쓰면서 매일 새로운 에피소드로 채우는 데 도가 튼 사람이라고 할 수 있다. 여하튼, 깃허브 잔디심기 6개월간 회고록을 적기 전, 깃허브를 시작하게 된 계기에 관해 얘기해보겠다. 🍖 깃허브(Github)를 처음 시작하게 된 계기 깃허브를 처음 알게 된 것은 대학교 3학년 때였다. 그때는 안드로이드(Android) GUI 설계를 하면서 디자인적 요소에 메말라 있는 상태였다. 그도 그럴 것이, 너무 평이한 기본 디자인은 나의 성향과 맞지 않았기 때문에 좀 더 평면적이면서 멋진 버튼 이미지를 찾기를 원했다. 함께 프로젝트를 진행했던 동아리 선배 중 한 분이 깃허브를 알려주었다. 그때는 README를 읽을 줄 몰라서 많이 헤매었고 ‘아 이런 게 있구나~’하고 넘겨버렸다. 지금 생각해보면 너무 아쉬움이 크다. 그때 바로 깃허브를 시작했다면 내 Repository는 좀 더 풍성해져 있었을 것이다! 그리고 몇 년 뒤, 국비 지원 교육을 받으면서 협업도구로써 깃허브를 다시 접하게 되었다. 그때 처음 계정을 생성했고, 팀원들을 잘 구슬려서 팀 프로젝트를 진행할 때 깃허브를 이용하려고 무진장 노력했다. 대부분이 깃허브를 이용해보지 않아 많이 어려워했으므로 공부가 많이 필요했다. Git Bash를 처음부터 사용하기 어려우니 회사에서 많이 사용한다고 익히 들은 Source Tree를 내려받았다. Commit, Push, Pull, Branch 등 온통 모르는 단어투성이였지만 구글링을 해가며 용어를 익혔다. 용어들에 익숙해질 때쯤 Commit 후 Master Branch에 Push하면 Contribution 영역에 초록색이 여러 가지 색깔로 칠해지는 것이 인상적이었다. Branch로 Merge하고 Rebase하고…. Branch 관련 개념이 어려워서 중간에 포기하고 싶을 때마다 나에게 강한 동기부여가 된 글이 있었는데, 이수진 님이 작성하신 깃허브로 취업하기 라는 글이었다. 이 글을 읽으며 깃허브를 이용하는 방식을 바꾸어나갔고 누군가의 1년간 Contribution 이미지가 첨부돼 있었는데, 한 해를 초록 들판으로 꽉 채운 이미지에 마음을 빼앗겼다고나 할까. 1일 1커밋을 해야겠다고 다짐하게 되었다. 👧 1일 1커밋을 하며 코덕(Co-duck)이 되다 1일 1커밋을 지속해서 할 수 있도록 동기부여가 된 요소는 2가지가 있다. 하나는 깃허브 잔디정원사라는 커뮤니티였고, 다른 하나는 코덕 이라는 사이트였다. 지금은 잔디정원사 커뮤니티에서 활동하고 있지는 않지만, 온·오프라인에서 다양한 분야의 개발자들을 알게 되면서 1일 1커밋 깃허브 관리를 통해 나의 개발실력을 향상하고자 하는 데 강한 자극이 되었다. 코덕 이라는 사이트에 대해 소개해야 할 것이 많은데, 간략히 소개하자면 권용근 님의 개인 사이드 프로젝트 중 하나로 깃허브 활동 장려를 위한 사이트이다. 다양한 지표를 기준으로 순위시스템을 구축해놔서 타 사용자와 알게 모르게 경쟁심리를 자극한다. 국비 지원 교육을 받으면서 그날그날 배운 내용을 커밋하곤 했는데, 잔디정원사에서 알게 된 지인들과 엎치락뒤치락 순위 경쟁하는 것이 참으로 재밌었다. 시각적으로 하루 할당량을 얼마나 했는지 눈에 보이게 되는 셈이니, 초반에는 코드를 한 줄이라도 더 적으려고 머리 쓴 적도 많았던 것 같다. 아쉬운 점이라면 국비 지원 교육을 수료하고 본격적으로 취업 전선에 뛰어들어 구직활동을 하다 보니 1일 1커밋을 놓친 날도 몇 번 있었다. 그리고 영문도 모르게 뻥 뚫려버린 날이 딱 하나 있지만 지금도 원인을 찾지 못했다. 그동안 나만의 100일 프로젝트 목표를 세우고, 1일 1커밋을 제대로 실천했다. 2019년 시즌 06, 07, 08에서 3번 연속 TOP 10 순위권에 들었다. 각각 6등, 5등, 5등 이렇게 받았다. 순위권에 있다 보니 알게 모르게 모르는 분들한테 팔로워도 받았던 적도 있었다. 📌 깃허브 잔디심기에 대한 일침 개발자라면 누구나 Git이나 Github 혹은 Gitlab을 하게 될 것이다. 그래서 더 중요하게 생각했고, 그만큼 깃허브 잔디심기가 나의 개발경험 중 큰 부분을 차지하고 있다. 자기소개서에 깃허브와 코덕 얘기를 쓴 적이 있었는데, 한 번은 면접을 보면서 VCS에 대한 질문이 나왔다. 당연히 Git Bash도 사용해봤고 Github도 사용해봤더니 일일커밋에 대해 신나게 얘기했는데 내 깃허브의 잔디를 본 면접관님이 툭 내뱉은 말이 인상적이었다. “일일커밋해서 축구장 만드실 거에요?” 그때는 눈빛을 반짝이며 웃으면서, “네! 그것도 좋겠네요!”라고 말했던 것 같다. 내 주변 개발자 지인들은 깃허브 일일커밋이 무슨 의미가 있느냐고 평가절하하기도 한다. “그거 별로 안 중요해. 무엇을 커밋하는게 중요한 거지”라고 말하곤 한다. 매일 의미 있는 커밋을 했느냐고 누군가 묻는다면, 솔직하게 까놓고 말해서 부끄럽지만 나는 아니었다고 몇 번은 텍스트만 고친 적 있다고 대답한 적이 있다. 한창 의미 있는 커밋을 할 때는 프로젝트 단위로 올렸는데, README의 중요성을 알게 된 후에는 좀 더 신경 쓰게 된 것 같다. 📚 일일커밋에 대한 철학 나의 깃허브 잔디심기에 대한 철학 중 하나는 일일커밋으로써 어떤 지식을 차곡차곡 쌓아나가거나, 내가 어떤 것을 진행하고 있고, 그것에 몰입하고 있다는 것을 시각적으로 확인할 수 있어서 유용하다는 것이다. 질이 높은 프로그램을 매일 매일 만들어내면 좋겠지만 생각보다 쉽지 않다. 나는 천재가 아니므로 개발을 하다 보면 버그도 생기고 이슈도 생긴다. 내가 지금 집중하고 있는 것이 어떤 것인지 이력이 남는다는 것, 기록되고 있다는 것에 큰 가치를 두고 있다. 그리고 게임을 하는 것만큼 잔디를 심는 일이 생각보다 재미있다. 이동욱 님의 일일커밋의 효용성이란 글을 읽은 적이 있는데, 매우 공감이 가는 글귀가 있다. 일일커밋은 완벽하진 않지만 이를 보여준다. 나한테 일일커밋은 공부/자기개발이 아니라 그냥 게임일 뿐이다.레벨업하듯이, 게임 속 화폐를 모으듯이 차곡차곡 쌓이는 게 보이는 RPG 게임 같은 거라 정말 중독성 있다. 1일 1커밋으로 유명한 이동욱 님은 어떻게 1년을 다 채우셨는지…. 정말 대단하다는 생각이 들었다. 그리고 더욱 정진하여 본받아야겠다. 📆 앞으로의 계획 사실 깃허브는 혼자 사용하는 것보다 협업도구로써 사용하는 데 더 의미가 있다고 생각한다. 그리고 내가 올려놓은 코드 중 이렇게 바꿔야지 저렇게 바꿔야지 싶은 부분들이 종종 보여서, 어떻게 하면 무결점 코드로 작성할 수 있을지 계속 고민하게 될 것 같다. 진행 중인 장기 프로젝트와 토이 프로젝트, 계획하고 있는 프로젝트를 깃허브에 커밋할 수 있도록 할 예정이다.","link":"/Devlog/Essay/2019/11/06/Essay-Github-Grass-Plantation-A-Memoir-for-6-Month/"}],"tags":[{"name":"Review","slug":"Review","link":"/tags/Review/"},{"name":"NHN","slug":"NHN","link":"/tags/NHN/"},{"name":"Public Recruitment Session","slug":"Public-Recruitment-Session","link":"/tags/Public-Recruitment-Session/"},{"name":"채용설명회","slug":"채용설명회","link":"/tags/채용설명회/"},{"name":"Job Hunter","slug":"Job-Hunter","link":"/tags/Job-Hunter/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Issues","slug":"Issues","link":"/tags/Issues/"},{"name":"언어","slug":"언어","link":"/tags/언어/"},{"name":"이슈해결/이슈등록","slug":"이슈해결-이슈등록","link":"/tags/이슈해결-이슈등록/"},{"name":"에러메시지","slug":"에러메시지","link":"/tags/에러메시지/"},{"name":"Computer Science","slug":"Computer-Science","link":"/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Insertion Sort","slug":"Insertion-Sort","link":"/tags/Insertion-Sort/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"Quick Sort","slug":"Quick-Sort","link":"/tags/Quick-Sort/"},{"name":"Counting Sort","slug":"Counting-Sort","link":"/tags/Counting-Sort/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"DFS Searching","slug":"DFS-Searching","link":"/tags/DFS-Searching/"},{"name":"BFS Searching","slug":"BFS-Searching","link":"/tags/BFS-Searching/"},{"name":"Parametric Search","slug":"Parametric-Search","link":"/tags/Parametric-Search/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Permutation","slug":"Permutation","link":"/tags/Permutation/"},{"name":"Combination","slug":"Combination","link":"/tags/Combination/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Priority Queue","slug":"Priority-Queue","link":"/tags/Priority-Queue/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Devlog","slug":"Devlog","link":"/tags/Devlog/"},{"name":"Jekyll","slug":"Jekyll","link":"/tags/Jekyll/"},{"name":"찬미의 개발블로그","slug":"찬미의-개발블로그","link":"/tags/찬미의-개발블로그/"},{"name":"개발블로그","slug":"개발블로그","link":"/tags/개발블로그/"},{"name":"커뮤니티","slug":"커뮤니티","link":"/tags/커뮤니티/"},{"name":"이슈등록","slug":"이슈등록","link":"/tags/이슈등록/"},{"name":"Collections","slug":"Collections","link":"/tags/Collections/"},{"name":"Arrays","slug":"Arrays","link":"/tags/Arrays/"},{"name":"이슈해결","slug":"이슈해결","link":"/tags/이슈해결/"},{"name":"java.lang.ArrayIndexOutOfBoundsException","slug":"java-lang-ArrayIndexOutOfBoundsException","link":"/tags/java-lang-ArrayIndexOutOfBoundsException/"},{"name":"Git Bash","slug":"Git-Bash","link":"/tags/Git-Bash/"},{"name":"Expo-CLI","slug":"Expo-CLI","link":"/tags/Expo-CLI/"},{"name":"Expo CLI is in non-interactive mode","slug":"Expo-CLI-is-in-non-interactive-mode","link":"/tags/Expo-CLI-is-in-non-interactive-mode/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"LF will be replaced by CRLF","slug":"LF-will-be-replaced-by-CRLF","link":"/tags/LF-will-be-replaced-by-CRLF/"},{"name":"Language","slug":"Language","link":"/tags/Language/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"잔디","slug":"잔디","link":"/tags/잔디/"},{"name":"Contribution","slug":"Contribution","link":"/tags/Contribution/"},{"name":"일일커밋","slug":"일일커밋","link":"/tags/일일커밋/"}],"categories":[{"name":"Devlog","slug":"Devlog","link":"/categories/Devlog/"},{"name":"Issues","slug":"Issues","link":"/categories/Issues/"},{"name":"Review","slug":"Devlog/Review","link":"/categories/Devlog/Review/"},{"name":"Hexo","slug":"Devlog/Hexo","link":"/categories/Devlog/Hexo/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","link":"/categories/Computer-Science/Algorithm/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","link":"/categories/Computer-Science/Data-Structure/"},{"name":"Issues","slug":"Devlog/Issues","link":"/categories/Devlog/Issues/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Java","slug":"Language/Java","link":"/categories/Language/Java/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","link":"/categories/Computer-Science/Operating-System/"},{"name":"Essay","slug":"Devlog/Essay","link":"/categories/Devlog/Essay/"}]}