{"pages":[{"title":"About","text":"","link":"/About/index.html"}],"posts":[{"title":"알고리즘 | 삽입 정렬 (Insertion Sort)","text":"Algorithm : Insertion Sort(삽입 정렬) 삽입 정렬은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다. 예시문제 주어진 데이터를 Insertion Sort를 사용하여 정렬 하시오. 데이터의 최대 크기는 100이다. 입력 출력 1 // 전체 Test case 수 5 // 데이터 크기 1 4 5 2 3 #1 1 2 3 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Scanner; class Solution { static int input[]; static int num; static void insertionSort() { for (int i = 1; i &lt; num; i++) { int temp = input[i]; int j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; } } static void printResult() { int i; for (i = 0; i &lt; num; ++i) { System.out.print(input[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { num = sc.nextInt(); input = new int[num]; for (int i = 0; i &lt; num; i++) { input[i] = sc.nextInt(); } insertionSort(); System.out.print(\"#\" + test_case + \" \"); printResult(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt; #define MAX_NUM 100 int input[MAX_NUM];int num; void insertionSort(void){ int temp; int i; int j; for (i = 1; i &lt; num; i++) { temp = input[i]; j = i - 1; while ((j &gt;= 0) &amp;&amp; (temp &lt; input[j])) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = temp; }} void printResult(void){ int i; for (i = 0; i &lt; num; ++i) { printf(\"%d \", input[i]); } printf(\"\\n\");} int main(void){ int T; int test_case; int i; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;num); for (i = 0; i &lt; num; i++) { scanf(\"%d\", &amp;input[i]); } insertionSort(); printf(\"#%d \", test_case); printResult(); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/24/Algorithm-Insertion-Sort/"},{"title":"알고리즘 | 재귀(Recursion)","text":"Algorithm : Recursion(재귀) 재귀는 수학이나 컴퓨터 과학 등에서 자신을 정의할 때 자기 자신을 재참조하는 방법을 뜻합니다. 주로 이 방법은 함수에 적용한 재귀 함수(Recursion Function)의 형태로 많이 사용됩니다. 예시문제 주어지는 수가 1 이상 20 이하의 수일 때, 주어진 수의 Factorial 값을 구해 아래와 같이 출력하시오. 입력 출력 3 // 전체 Test case 수 9 // Test case index 12 20 #1 9! = 362880 #2 12! = 479001600 #3 20! = 2432902008176640000 Java12345678910111213141516171819202122232425262728293031323334import java.util.Scanner; class Solution { static long factorial(int num) { if (num == 0) { return 1; } else { return num * factorial(num - 1); } } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int num = sc.nextInt(); long value = factorial(num); System.out.println(\"#\" + test_case + \" \" + num + \"! = \" + value); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; long long factorial(int num){ if (num == 0) { return 1; } else { return num * factorial(num - 1); }} int main(void){ int test_case; int T; int num; long long value; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d\", &amp;num); value = factorial(num); printf(\"#%d %d! = %lld\\n\", test_case, num, value); }} [참고자료] SW Expert Academy","link":"/Computer-Science/Algorithm/2019/07/20/Algorithm-Recursion/"},{"title":"자료구조 | 그래프 (Graph)","text":"Data Structure : Graph(그래프) 그래프(Graph)는 컴퓨터 시스템에서 연결되어 있는 객체간의 관계를 표현할 수 있는 자료구조입니다. 예시문제 첫째 줄에는 V와 E의 갯수, 정점의 정보를 묻는 쿼리의 갯수가 주어지고 둘째 줄부터 간선의 정보(연결된 정점의 번호쌍)가 주어진다. 그 다음 줄에는 정점의 인접정점들이 무엇인지 묻는 쿼리가 정점번호로 주어진다. 정점의 번호는 0~V-1까지 이며, 간선정보는 오름차순으로 나열되어 주어진다. 또한 중복 간선은 존재하지 않는다. 입력으로 주어지는 쿼리의 정점에 인접한 정점들을 각 줄에 출력하라. (2&lt;=V&lt;=100, 1&lt;=E&lt;=1000) 입력 출력 2 6 7 3 // 정점갯수, 간선갯수 쿼리(질문)갯수 0 1 // 간선정보 0 - 1 0 2 0 3 1 2 1 4 3 4 4 5 0 // 쿼리(질문): 정점 번호 2 4 9 10 3 0 1 0 2 0 6 1 3 1 4 1 7 2 4 4 5 6 7 7 8 0 1 7 #1 1 2 3 // 정점0에 인접한 정점리스트 0 1 // 정점2에 인접한 정점리스트 1 3 5 // 정점4에 인접한 정점리스트 #2 1 2 6 0 3 4 7 1 6 8 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.Scanner; class Graph{ class AdjlistNode { int vertex; AdjlistNode next; public AdjlistNode(int v) { vertex = v; next = null; } } class AdjList { int num_members; AdjlistNode head; AdjlistNode tail; public AdjList() { num_members = 0; head = tail = null; } } int num_vertices; AdjList []adjListArr; public Graph(int n) { num_vertices = n; adjListArr = new AdjList[n]; for (int i = 0; i &lt; n; i++) { adjListArr[i] = new AdjList(); } } void addEdge(int src, int dest) { AdjlistNode newNode = new AdjlistNode(dest); if (adjListArr[src].tail != null) { adjListArr[src].tail.next = newNode; adjListArr[src].tail = newNode; } else { adjListArr[src].head = adjListArr[src].tail = newNode; } adjListArr[src].num_members++; newNode = new AdjlistNode(src); if (adjListArr[dest].tail != null) { adjListArr[dest].tail.next = newNode; adjListArr[dest].tail = newNode; } else { adjListArr[dest].head = adjListArr[dest].tail = newNode; } adjListArr[dest].num_members++; } void display(int i) { AdjlistNode adjList = adjListArr[i].head; while (adjList != null) { System.out.printf(\"%d \", adjList.vertex); adjList = adjList.next; } System.out.printf(\"\\n\"); }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int V = sc.nextInt(); int E = sc.nextInt(); int Q = sc.nextInt(); Graph graph = new Graph(V); for (int i = 0; i &lt; E; i++) { int sv = sc.nextInt(); int ev = sc.nextInt(); graph.addEdge(sv, ev); } System.out.printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { int sv = sc.nextInt(); graph.display(sv); } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;malloc.h&gt; typedef struct adjlistNode{ int vertex; adjlistNode *next;} AdjlistNode; typedef struct{ int num_members; AdjlistNode *head; AdjlistNode *tail;} AdjList; typedef struct{ int num_vertices; AdjList * adjListArr;} Graph; AdjlistNode * createNode(int v){ AdjlistNode * newNode = (AdjlistNode *)malloc(sizeof(AdjlistNode)); newNode-&gt;vertex = v; newNode-&gt;next = NULL; return newNode;} Graph * createGraph(int n){ Graph * graph = (Graph *)malloc(sizeof(Graph)); graph-&gt;num_vertices = n; graph-&gt;adjListArr = (AdjList *)malloc(n * sizeof(AdjList)); for (int i = 0; i &lt; n; i++) { graph-&gt;adjListArr[i].head = graph-&gt;adjListArr[i].tail = NULL; graph-&gt;adjListArr[i].num_members = 0; } return graph;} void destroyGraph(Graph * graph){ if (graph) { if (graph-&gt;adjListArr) { for (int v = 0; v &lt; graph-&gt;num_vertices; v++) { AdjlistNode * adjListPtr = graph-&gt;adjListArr[v].head; while (adjListPtr) { AdjlistNode * tmp = adjListPtr; adjListPtr = adjListPtr-&gt;next; free(tmp); } } free(graph-&gt;adjListArr); } free(graph); }} void addEdge(Graph *graph, int src, int dest){ AdjlistNode * newNode = createNode(dest); if (graph-&gt;adjListArr[src].tail != NULL) { graph-&gt;adjListArr[src].tail-&gt;next = newNode; graph-&gt;adjListArr[src].tail = newNode; } else { graph-&gt;adjListArr[src].head = graph-&gt;adjListArr[src].tail = newNode; } graph-&gt;adjListArr[src].num_members++; newNode = createNode(src); if (graph-&gt;adjListArr[dest].tail != NULL) { graph-&gt;adjListArr[dest].tail-&gt;next = newNode; graph-&gt;adjListArr[dest].tail = newNode; } else { graph-&gt;adjListArr[dest].head = graph-&gt;adjListArr[dest].tail = newNode; } graph-&gt;adjListArr[dest].num_members++;} void displayGraph(Graph * graph, int i){ AdjlistNode * adjListPtr = graph-&gt;adjListArr[i].head; while (adjListPtr) { printf(\"%d \", adjListPtr-&gt;vertex); adjListPtr = adjListPtr-&gt;next; } printf(\"\\n\");} int main(int argc, char* argv[]){ int T, V, E, Q, sv, ev; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d %d %d\", &amp;V, &amp;E, &amp;Q); Graph * graph = createGraph(V); for (int i = 0; i &lt; E; i++) { scanf(\"%d %d\", &amp;sv, &amp;ev); addEdge(graph, sv, ev); } printf(\"#%d\\n\", test_case); for (int i = 0; i &lt; Q; i++) { scanf(\"%d\", &amp;sv); displayGraph(graph, sv); } } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/27/Data-Structure-Graph/"},{"title":"자료구조 | 해시 (Hash)","text":"Data Structure : Hash(해시) 해시 테이블(Hash table)은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추가에 사용되는 자료 구조입니다. 해시 테이블은 해시 함수를 사용하여 색인(index, Key)을 버킷(bucket)이나 슬롯(slot)의 배열로 계산합니다. 예시문제 주어진 N개의 key, data쌍을 Hash table에 입력한 후, Q개의 key를 입력 받아 key에 해당하는 data를 각 줄에 출력하시오. (1&lt;=N, Q&lt;=4096) Key : 최대 64개의 문자열 Data : 최대 128개의 문자열 입력 출력 123123123234serf 234sdfdfgdcvb Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Hashtable{ class Hash { String key; String data; } int capacity; Hash tb[]; public Hashtable(int capacity){ this.capacity = capacity; tb = new Hash[capacity]; for (int i = 0; i &lt; capacity; i++){ tb[i] = new Hash(); } } private int hash(String str) { int hash = 5381; for (int i = 0; i &lt; str.length(); i++) { int c = (int)str.charAt(i); hash = ((hash &lt;&lt; 5) + hash) + c; } if (hash &lt; 0) hash *= -1; return hash % capacity; } public String find(String key){ int h = hash(key); int cnt = capacity; while(tb[h].key != null &amp;&amp; (--cnt) != 0) { if (tb[h].key.equals(key)){ return tb[h].data; } h = (h + 1) % capacity; } return null; } boolean add(String key, String data) { int h = hash(key); while(tb[h].key != null) { if (tb[h].key.equals(key)){ return false; } h = (h + 1) % capacity; } tb[h].key = key; tb[h].data = data; return true; }} class Solution{ final static int MAX_TABLE = 4096; public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { Hashtable tb = new Hashtable(MAX_TABLE); int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { String k = sc.next(); String d = sc.next(); tb.add(k, d); } System.out.printf(\"#%d\\n\", test_case); int Q = sc.nextInt(); for (int i = 0; i &lt; Q; i++) { String k = sc.next(); String d = tb.find(k); if (d != null) { System.out.printf(\"%s\\n\", d); } else { System.out.printf(\"not find\\n\"); } } } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt; #define MAX_KEY 64#define MAX_DATA 128#define MAX_TABLE 4096 typedef struct{ char key[MAX_KEY + 1]; char data[MAX_DATA + 1];}Hash;Hash tb[MAX_TABLE]; unsigned long hash(const char *str){ unsigned long hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;} int find(const char *key, char *data){ unsigned long h = hash(key); int cnt = MAX_TABLE; while (tb[h].key[0] != 0 &amp;&amp; cnt--) { if (strcmp(tb[h].key, key) == 0) { strcpy(data, tb[h].data); return 1; } h = (h + 1) % MAX_TABLE; } return 0;} int add(const char *key, char *data){ unsigned long h = hash(key); while (tb[h].key[0] != 0) { if (strcmp(tb[h].key, key) == 0) { return 0; } h = (h + 1) % MAX_TABLE; } strcpy(tb[h].key, key); strcpy(tb[h].data, data); return 1;} int main(int argc, char* argv[]){ int T, N, Q; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { memset(tb, 0, sizeof(tb)); scanf(\"%d\", &amp;N); char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; for (int i = 0; i &lt; N; i++) { scanf(\"%s %s\\n\", &amp;k, &amp;d); add(k, d); } printf(\"#%d\\n\", test_case); scanf(\"%d\", &amp;Q); for (int i = 0; i &lt; Q; i++) { char k[MAX_KEY + 1]; char d[MAX_DATA + 1]; scanf(\"%s\\n\", &amp;k); if (find(k, d)) { printf(\"%s\\n\", d); } else { printf(\"not find\\n\"); } } } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/25/Data-Structure-Hash/"},{"title":"자료구조 | 연결리스트 (Linked List)","text":"Data Structure : Linked List(연결리스트) 연결리스트(Linked List)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로, 데이터를 저장하는 자료 구조입니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Linked List에 넣은 후, 2개의 간격으로 하나씩 데이터를 뺄 때 마지막에 남아 있는 데이터를 출력하시오. Ex) 1 2 3 4 5 -&gt; 2 3 4 5 -&gt; 2 3 5 -&gt; 2 5 -&gt; 2 입력 출력 2 //테스트 케이스 수 5 //입력 수 1 2 3 4 5 //입력 데이터 6 1 2 3 4 5 6 #1 2 #2 5 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.Scanner; class ListNode { int data; ListNode prev; ListNode next; public ListNode() { data = 0; prev = this; next = this; } public static ListNode appendListNode(ListNode head, int data) { ListNode node = new ListNode(); node.data = data; if (head == null) { head = node; } else { ListNode last = head.prev; last.next = node; head.prev = node; node.prev = last; node.next = head; } return head; } public static ListNode removeListNode(ListNode head, ListNode node) { if (head == head.next) { return null; } else { ListNode prevNode = node.prev; ListNode nextNode = node.next; prevNode.next = nextNode; nextNode.prev = prevNode; return (head == node) ? nextNode : head; } }} class Solution{ public static void main(String args[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { ListNode head = null; int N = sc.nextInt(); for (int i = 0; i &lt; N; i++) { int data = sc.nextInt(); head = ListNode.appendListNode(head, data); } ListNode node = head; while(head != head.next) { ListNode nextNode = node.next; head = ListNode.removeListNode(head, node); node = nextNode.next.next; } System.out.printf(\"#%d %d\\n\", test_case, head.data); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt; #define MAX_NODE 100 typedef struct listNode{ int data; struct listNode* prev; struct listNode* next;} ListNode; typedef struct{ int use; ListNode node;} ListNodeHeap; ListNodeHeap heap[MAX_NODE]; void initHeap(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { heap[i].use = 0; }} void initListNode(ListNode* node){ node-&gt;data = 0; node-&gt;prev = node; node-&gt;next = node;} ListNode* getListNode(void){ int i; for (i = 0; i &lt; MAX_NODE; i++) { if (!heap[i].use) { heap[i].use = 1; initListNode(&amp;heap[i].node); return &amp;heap[i].node; } } return NULL;} void destroyListNode(ListNode* node){ ListNodeHeap* heap_node = (ListNodeHeap*)((int*)node - 1); heap_node-&gt;use = 0;} ListNode* appendListNode(ListNode* list, int data){ ListNode* node = getListNode(); node-&gt;data = data; if (list == NULL) { return node; } else { ListNode* last = list-&gt;prev; last-&gt;next = node; list-&gt;prev = node; node-&gt;prev = last; node-&gt;next = list; return list; }} ListNode* removeListNode(ListNode* list, ListNode* node){ if (list == list-&gt;next) { destroyListNode(node); return NULL; } else { ListNode* prev = node-&gt;prev; ListNode* next = node-&gt;next; prev-&gt;next = next; next-&gt;prev = prev; destroyListNode(node); return (list == node) ? next : list; }} int main(int argc, char* argv[]){ int T, N; setbuf(stdout, NULL); scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; ++test_case) { ListNode* list = NULL; ListNode* node; int i; initHeap(); scanf(\"%d\", &amp;N); for (i = 0; i &lt; N; i++) { int data; scanf(\"%d\", &amp;data); list = appendListNode(list, data); } node = list; while (list != list-&gt;next) { ListNode* nextNode = node-&gt;next; list = removeListNode(list, node); node = nextNode-&gt;next-&gt;next; } printf(\"#%d %d\\n\", test_case, list-&gt;data); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/28/Data-Structure-Linked-List/"},{"title":"자료구조 | 우선순위 큐 (Priority Queue)","text":"Data Structure : Priority Queue(우선순위 큐) 우선순위 큐는 높은 우선순위를 가진 원소는 낮은 우선순위를 가진 원소보다 먼저 처리되는 자료구조입니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 작은 숫자가 높은 우선순위를 갖는 Priority Queue에 저장하고, 우선 순위가 높은 숫자부터 차례대로 출력하시오.(입력에는 오류가 없다고 가정) 입력 출력 2 //테스트 케이스 수 10 //입력 수 10 49 38 17 56 92 8 1 13 55 //입력 데이터 13 4 22 50 13 5 1 22 35 21 7 99 100 14 #1 1 8 10 13 17 38 49 55 56 92 #2 1 4 5 7 13 14 21 22 22 35 50 99 100 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.Scanner; class Solution { static Scanner sc; static final int MAX_SIZE = 100; static int heap[] = new int[MAX_SIZE]; static int heapSize = 0; static void heapInit() { heapSize = 0; } static void heapPush(int value) { if (heapSize + 1 &gt; MAX_SIZE) { return; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; } static int heapPop() { if (heapSize &lt;= 0) { return -1; } int value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current &lt; heapSize &amp;&amp; current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 &gt;= heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return value; } static void heapPrint(int[] heap, int heap_size) { for (int i = 0; i &lt; heap_size; i++) { System.out.print(heap[i] + \" \"); } System.out.println(); } public static void main(String arg[]) throws Exception { sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); heapInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); heapPush(value); } System.out.print(\"#\" + test_case + \" \"); for (int i = 0; i &lt; N; i++) { System.out.print(heapPop() + \" \"); } System.out.println(); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt; #define MAX_SIZE 100 int heap[MAX_SIZE];int heapSize = 0; void heapInit(void){ heapSize = 0;} int heapPush(int value){ if (heapSize + 1 &gt; MAX_SIZE) { printf(\"queue is full!\"); return 0; } heap[heapSize] = value; int current = heapSize; while (current &gt; 0 &amp;&amp; heap[current] &lt; heap[(current - 1) / 2]) { int temp = heap[(current - 1) / 2]; heap[(current - 1) / 2] = heap[current]; heap[current] = temp; current = (current - 1) / 2; } heapSize = heapSize + 1; return 1;} int heapPop(int *value){ if (heapSize &lt;= 0) { return -1; } *value = heap[0]; heapSize = heapSize - 1; heap[0] = heap[heapSize]; int current = 0; while (current * 2 + 1 &lt; heapSize) { int child; if (current * 2 + 2 == heapSize) { child = current * 2 + 1; } else { child = heap[current * 2 + 1] &lt; heap[current * 2 + 2] ? current * 2 + 1 : current * 2 + 2; } if (heap[current] &lt; heap[child]) { break; } int temp = heap[current]; heap[current] = heap[child]; heap[child] = temp; current = child; } return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); heapInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); heapPush(value); } printf(\"#%d \", test_case); for (int i = 0; i &lt; N; i++) { int value; heapPop(&amp;value); printf(\"%d \", value); } printf(\"\\n\"); } return 0;} [참고차료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/23/Data-Structure-Priority-Queue/"},{"title":"자료구조 | 큐 (Queue)","text":"Data Structure : Queue(큐) 큐는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말합니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Queue에 넣은 후 하나씩 꺼내 화면에 출력하시오. 입력 출력 2 // 테스트 케이스 수 5 // 데이터 크기 1 2 3 4 5 5 5 4 2 3 1 #1 1 2 3 4 5 #2 5 4 2 3 1 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Scanner; class Solution { static final int MAX_N = 100; static int front; static int rear; static int queue[] = new int[MAX_N]; static void queueInit() { front = 0; rear = 0; } static boolean queueIsEmpty() { return (front == rear); } static boolean queueIsFull() { if ((rear + 1) % MAX_N == front) { return true; } else { return false; } } static boolean queueEnqueue(int value) { if (queueIsFull()) { System.out.print(\"queue is full!\"); return false; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return true; } static Integer queueDequeue() { if (queueIsEmpty()) { System.out.print(\"queue is empty!\"); return null; } Integer value = new Integer(queue[front]); front++; if (front == MAX_N) { front = 0; } return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); queueInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); queueEnqueue(value); } System.out.print(\"#\" + test_case + \" \"); while (!queueIsEmpty()) { Integer value = queueDequeue(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt; #define MAX_N 100 int front;int rear;int queue[MAX_N]; void queueInit(void){ front = 0; rear = 0;} int queueIsEmpty(void){ return (front == rear);} int queueIsFull(void){ if ((rear + 1) % MAX_N == front) { return 1; } else { return 0; }} int queueEnqueue(int value){ if (queueIsFull()) { printf(\"queue is full!\"); return 0; } queue[rear] = value; rear++; if (rear == MAX_N) { rear = 0; } return 1;} int queueDequeue(int *value){ if (queueIsEmpty()) { printf(\"queue is empty!\"); return 0; } *value = queue[front]; front++; if (front == MAX_N) { front = 0; } return 1;} int main(int argc, char* argv[]){ int T; int N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); queueInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); queueEnqueue(value); printf(\"setValue\"); } printf(\"#%d \", test_case); while (!queueIsEmpty()) { int value; if (queueDequeue(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/22/Data-Structure-Queue/"},{"title":"자료구조 | 스택 (Stack)","text":"Data Structure : Stack(스택) 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조(LIFO - Last In First Out)로 데이터를 저장하는 형식을 말합니다. 예시문제 주어진 N(2&lt;= N &lt;=100)개의 수를 순서대로 Stack에 넣은 후 하나씩 꺼내 화면에 출력하시오. 입력 출력 2 // 테스트 케이스 수 5 // 데이터 크기 1 2 3 4 5 5 5 4 2 3 1 #1 5 4 3 2 1 #2 1 3 2 4 5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Scanner; class Solution { static final int MAX_N = 100; static int top; static int stack[] = new int[MAX_N]; static void stackInit() { top = 0; } static boolean stackIsEmpty() { return (top == 0); } static boolean stackIsFull() { return (top == MAX_N); } static boolean stackPush(int value) { if (stackIsFull()) { System.out.println(\"stack overflow!\"); return false; } stack[top] = value; top++; return true; } static Integer stackPop() { if (top == 0) { System.out.println(\"stack is empty!\"); return null; } top--; Integer value = new Integer(stack[top]); return value; } public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; test_case++) { int N = sc.nextInt(); stackInit(); for (int i = 0; i &lt; N; i++) { int value = sc.nextInt(); stackPush(value); } System.out.print(\"#\" + test_case + \" \"); while (!stackIsEmpty()) { Integer value = stackPop(); if (value != null) { System.out.print(value.intValue() + \" \"); } } System.out.println(); } sc.close(); }} C/C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt; #define MAX_N 100 int top;int stack[MAX_N]; void stackInit(void){ top = 0;} int stackIsEmpty(void){ return (top == 0);} int stackIsFull(void){ return (top == MAX_N);} int stackPush(int value){ if (stackIsFull()) { printf(\"stack overflow!\"); return 0; } stack[top] = value; top++; return 1;} int stackPop(int *value){ if (top == 0) { printf(\"stack is empty!\"); return 0; } top--; *value = stack[top]; return 1;} int main(int argc, char* argv[]){ int T, N; scanf(\"%d\", &amp;T); for (int test_case = 1; test_case &lt;= T; test_case++) { scanf(\"%d\", &amp;N); stackInit(); for (int i = 0; i &lt; N; i++) { int value; scanf(\"%d\", &amp;value); stackPush(value); } printf(\"#%d \", test_case); while (!stackIsEmpty()) { int value; if (stackPop(&amp;value) == 1) { printf(\"%d \", value); } } printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/21/Data-Structure-Stack/"},{"title":"자료구조 | 트리 (Tree)","text":"Data Structure : Tree(트리) 트리 구조란 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조입니다. 간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리(Tree)라고 부릅니다. 예시문제 주어진 입력 값으로 트리를 구성하고, 구성된 트리를 전위순회하고 방문한 노드의 번호를 출력하시오. 첫 줄에는 전체 테스트 케이스의 수(T), 두 번째 줄에는 노드의 총 수(nodeNum), 간선의 총 수(edgeNum)가 주어진다. 그 다음 줄에는 간선이 나열 된다. 간선은 그것을 이루는 두 정점으로 표기된다. 간선은 항상 “부모 자식” 순서로 표기 된다. 예를 들어 “1 2”는 정점 1과 2를 잇는 간선을 의미하며 1이 부모 2가 자식을 의미한다. 부모는 최대 2개의 자식 노드를 갖으며, 최대 노드의 개수는 10000개이다. 입력 출력 2 // Testcase 수 13 12 // N: 노드의 총 수, E: 간선의 총 수 1 2 1 3 2 4 3 5 3 6 4 7 7 12 5 9 5 8 6 11 6 10 11 13 // 간선 정보 (“부모 자식” 순서) 10 9 1 2 1 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 #1 1 2 4 7 12 3 5 9 8 6 11 13 10 #2 1 2 3 4 5 6 7 8 9 10 Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.Scanner; class Tree { static final int MAX_CHILD_NUM = 2; class TreeNode { int parent; int []child = new int[MAX_CHILD_NUM]; public TreeNode(int parent) { this.parent = parent; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { child[i] = -1; } } } TreeNode []treenode; int nodeNum; public Tree(int nodeNum) { this.nodeNum = nodeNum; treenode = new TreeNode[nodeNum+1]; for (int i = 0; i &lt;= nodeNum; i++) { treenode[i] = new TreeNode(-1); } } public void addChild(int parent, int child) { int found = -1; for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { if (treenode[parent].child[i] == -1) { found = i; break; } } if (found == -1) return; treenode[parent].child[found] = child; treenode[child].parent = parent; } public int getRoot() { for (int i = 1; i &lt; nodeNum; i++) { if (treenode[i].parent == -1) { return i; } } return -1; } public void preOrder(int root) { System.out.printf(\"%d \", root); for (int i = 0; i &lt; MAX_CHILD_NUM; i++) { int child = treenode[root].child[i]; if (child != -1) { preOrder(child); } } }} class Solution { public static void main(String arg[]) throws Exception { Scanner sc = new Scanner(System.in); int T = sc.nextInt(); for (int test_case = 1; test_case &lt;= T; ++test_case) { int node = sc.nextInt(); int edge = sc.nextInt(); Tree tree = new Tree(node); for (int i = 0; i &lt; edge; i++) { int parent = sc.nextInt(); int child = sc.nextInt(); tree.addChild(parent, child); } int root = tree.getRoot(); System.out.printf(\"#%d \", test_case); tree.preOrder(root); System.out.printf(\"\\n\"); } sc.close(); }} C/C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt; #define MAX_NODE_NUM 10000#define MAX_CHILD_NUM 2 typedef struct{ int parent; int child[MAX_CHILD_NUM];} TreeNode;TreeNode tree[MAX_NODE_NUM];int nodeNum;int edgeNum;int root; void initTree(void) { int i; int j; for (i = 0; i &lt;= nodeNum; i++) { tree[i].parent = -1; for (j = 0; j &lt; MAX_CHILD_NUM; j++) { tree[i].child[j] = -1; } }} void addChild(int parent, int child) { int i; for (i = 0; i &lt; MAX_CHILD_NUM; i++) { if (tree[parent].child[i] == -1) { break; } } tree[parent].child[i] = child; tree[child].parent = parent;} int getRoot(void) { int i; int j; for (i = 1; i &lt;= nodeNum; i++) { if (tree[i].parent == -1) { return i; } } return -1;} void preOrder(int root) { int i; int child; printf(\"%d \", root); for (i = 0; i &lt; MAX_CHILD_NUM; i++) { child = tree[root].child[i]; if (child != -1) { preOrder(child); } }} int main(void){ int test_case; int T; int i; int parent; int child; scanf(\"%d\", &amp;T); for (test_case = 1; test_case &lt;= T; ++test_case) { scanf(\"%d %d\", &amp;nodeNum, &amp;edgeNum); initTree(); for (i = 0; i &lt; edgeNum; i++) { scanf(\"%d %d\", &amp;parent, &amp;child); addChild(parent, child); } root = getRoot(); printf(\"#%d \", test_case); preOrder(root); printf(\"\\n\"); } return 0;} [참고자료] SW Expert Academy","link":"/Computer-Science/Data-Structure/2019/07/26/Data-Structure-Tree/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/Devlog/Hexo/2019/06/03/hello-world/"},{"title":"운영체제 | #01 운영체제 소개","text":"1. 운영체제 소개(1) 개요운영체제란? 컴퓨터 하드웨어와 컴퓨터 사용자 간의 매개체 역할을 하는 시스템 소프트웨어 컴퓨터 자원을 통제하고 할당하는 공통 기능을 컴퓨터웨어 소프트웨어 하나로 통합한 것 커널(Kernel) 운영체제의 핵심으로 메모리에 상주하며 운영체제의 다른 부분 또는 응용 프로그램 수행에 필요한 환경을 설정하는 소프트웨어 목적 컴퓨터 시스템을 편리하게 이용 컴퓨터 하드웨어를 효율적으로 관리 컴퓨터 자원 관리 측면에서의 운영체제의 역할 조정자 운영체제는 시스템을 운영하여 여러 운영 요소(하드웨어, 소프트웨어(프로그램), 데이터)를 적절하게 사용할 수 있도록 제어 자원 할당자 또는 관리자 컴퓨터 시스템이 문제를 해결하는 데 필요한 자원(프로세서 시간, 메모리 공간, 파일 저장 공간, 입출력장치 등)을 할당하는 업무 입출력장치와 사용자 프로그램 제어 컴퓨터 시스템의 부적절한 사용이나 오류를 방지하기 위해 사용자 프로그램의 실행의 제어 입출력장치를 동작시키고 통제하는 역할 컴퓨터 시스템 구성요소와 운영체제 (2) 운영체제의 역할과 목적운영체제의 목적 운영체제는 두 가지 주요 목적을 달성하기 위해 발전 편리성 : 사용자가 프로그램을 개발하고 사용하는 데 좀 더 편리한 환경 제공 효율성 : 자원을 효과적으로 사용하기 위해 각 프로그램을 유기적으로 결합하여 시스템 전체 성능을 향상시키는 방향으로 설계 처리능력 : 시스템의 생산성을 나타내는 대표 지표로 단위 시간당 처리하는 작업량 신뢰도 : 하드웨어(펌웨어), 소프트웨어가 실패 없이 주어진 기능을 수행할 수 있는 능력 응답시간 : 사용자가 시스템에 작업을 의뢰한 후 반응을 얻을 때까지의 시간 (시분할 방식 시스템과 온라인 시스템에서 사용하는 용어, 일괄 처리 시스템에서는 Turn Around Time) 사용가능도(가동률) : 사용자가 일정 기간 동안 컴퓨터를 실제로 사용한 시간(비율) (3) 운영체제의 유형일괄 처리 시스템(batch processing system) 유휴 상태의 시간을 없애기 위하여 작업 순서의 자동화(automatic job sequencing) 개념이 도입 상주 모니터(resident monitor)를 수행 작업의 준비 및 실행 순서를 자동화함으로써 시스템의 성능을 증진 다중 프로그래밍 시스템(multi programming system) 중앙처리장치가 항상 수행되도록 하여 그 이용도를 높이기 위한 방안 주기억장치 내에 여러 프로그램들이 존재하도록 시분할 시스템(time-sharing system) 여러 사용자들이 컴퓨터 자원에 대한 짧은 시간 단위의 공유(sharing) 사용자는 대화식(interactive) 단말장치를 이용하여 시분할 시스템과 인터페이스를 수행 실시간시스템(real-time system) 매우 엄격하게 정의되어 있는 시간 제약 등과 같은 사건들의 제시된 상황을 분석 사전에 정의된 제약 내에서 수행되어야 함 다중 처리 시스템(multiprocessing system) 밀착된 결합(tightly coupled) 시스템 혹은 강결합 시스템라고도 함 병렬 시스템(parallel system)이라고도 함 공유기억장치(common memory)를 통하여 하나로 연결된 다중 처리기(multi-processor)의 제어 및 공유를 위한 시스템 개인용 컴퓨터 시스템 중앙처리장치와 주변장치 이용률을 최대화시키려는 노력 대신에 편리성과 응답성을 더 중요시 함 분산처리 시스템(distributed processing system) 느슨한 결합(loosely coupled) 시스템이라고도 함. 프로세서들이 기억장치와 클럭을 공유하지 않으며 각 프로세서들은 자신의 지역(local) 기억장치 보유 프로세서들은 고속의 버스(bus)나 전화선과 같은 다양한 통신 라인을 통해 서로 통신 자원을 가지고 있는 사이트는 서버(server)가 되며, 반면 다른 사이트에서의 클라이언트(client)나 사용자는 그 자원을 사용 멀티미디어 시스템(multimedia system) 다양한 미디어를 이용하여 멀티미디어 콘텐츠를 제작하기 위해 필요한 하드웨어와 소프트웨어로 구성 멀티미디어 콘텐츠를 제작하기 위한 저작도구(authoring tool)가 필요 임베디드 시스템(embedded system) 정의 마이크로프로세서 또는 마이크로컨트롤러를 내장하여 시스템 제작자가 의도한 몇 가지 혹은 특수한 기능만을 수행하도록 제작된 시스템 임베디드 운영체제의 강점 임베디드 시스템과 그 한정된 자원들의 능력에 맞게 최적화 (4) 운영체제의 발전 과정운영체제의 발전 과정 운영체제와 컴퓨터 구조는 서로 많은 영향을 끼쳤으며, 관찰을 통해 운영체제의 개념을 올바르게 이해할 수 있다. 하드웨어와 같이 “세대”라고 불리는 발전 단계를 거쳤으며, 그 과정은 아래의 표와 같다. (5) 운영체제에 대한 관점자원 관리자 관점 각 자원에 대한 수행 과정 자원의 상태를 추적·저장 어떤 프로세스가 언제 어떤 자원을 얼마나 사용할 것인지를 결정하기 위한 정책 수립 자원의 할당 자원의 회수 프로세스 관리 기능 중앙처리장치와 프로세스(process)의 상태를 추적·저장 프로세스 스케줄러(process scheduler) 기억장치 관리 기능 기억장치의 상태를 추적·저장 장치(device) 관리 기능 채널 등의 제어장치 및 입출력장치와 같은 각종 장치의 상태를 추적·저장 입출력 트래픽 제어기(I/O traffic controller) 입출력 스케줄 링(I/O scheduling) 정보 관리 기능 정보의 위치, 사용 여부 및 상태 등을 추적·관리 파일시 스템(file system)이리고도 함 프로세스 관점 하나의 작업이 제시되어 완료될 때까지 하나의 프로세스에 대하여 그 상태를 변환시키고 관리 [그림1-7] 다중 프로그래밍 시스템에서의 복수 프로세스 계층 구조 관점 자원 관리 루틴이 어떻게 수행되고, 이 루틴들이 상호간에 어디에 논리적으로 위치하는가 모듈화 된 자원 관리 [그림1-8] 계층적 기계 개념의 구성도 (6) 입출력 프로그래밍대부분의 컴퓨터에 있어서 입출력은 중앙처리장치와 비동기적(asynchronous)으로 수행즉, 중앙처리장치와 입출력장치에 대한 작동이 독립적이며, 수행상의 시간관계 규정이 없이 병행적으로 수행BIOS (basic input/output system) ROM에서 얻어낸 정보 부팅된 프로세스를 실행시키는 명령어들을 포함 컴퓨터 칩에 저장된 명령어들을 펌웨어(firmware)라고 함 BIOS를 뛰어넘는 확장성 펌웨어 인터페이스(EFI: extensible firmware interface)가 개발 부트 진행과정(boot process) 컴퓨터 가동을 위해 파워버튼을 누르면 부트 로더가 준비동작에 들어감 POST(Power-On Self-Test) 수행 다른 BIOS들이 해당 준비동작에 들어감. 유저가 원할 경우 BIOS 세팅들에 접근을 위해 즉시 ‘키’ 조작 시도함 잠깐 동안의 메모리 테스트가 수행되고 여러 파라메타들이 세트됨. 플러그와 플레이 디바이스들이 준비동작에 들어감 DMA(Direct Memory Access)채널을 위한 자원들과 IRQ(Interrupt Request)할당됨 부트 디바이스들이 정해지고 준비동작에 들어감 OS가 준비동작에 들어감 POST (power on self test) 성공적인 부팅 및 적정 수행의 확인을 위해 필요하드웨어에 대해 행하는 테스트 수행하는 일 초기BIOS의 완벽한 보전 확인 주기억장치의 할당, 확인 및 그 크기(size)의 결정 시스템 버스(buses)와 시스템디바이스의 할당 및 시작 다른 BIOS들의 시작허용 (비디오 또는 그래픽카드 등) 사용자에게 BIOS시스템 구성 페이지에 접근할 수 있는 권한부여 부트 디바이스 할당 및 부트 파일을 가진 디바이스 찾기 운영체제에 의해 요구되는 그 외 준비관련 태스크들의 마무리 작업의 수행 버퍼링(buffering) 입출력장치의 느린 속도를 보완하는 한 가지 방법 중앙처리장치와 입출력장치 간의 시간적 불균형을 극복 미리 읽혀진 레코드들이 존재하는 곳은 주기억장치의 일부 [그림1-9] 버퍼를 이용한 출력의 예 입출력장치의 느린 속도를 보완하여, 유휴시간이 없도록 프로세서의 연산 과정과 함께 어떤 작업의 입출력을 동시에 수행하는 기능 스풀링(SPOOLing) 디스크(disk)를 매우 큰 버퍼처럼 사용하는 것 채널(channel) 출력장치와 중앙처리장치 사이에 입출력 전담 처리기 [그림1-10] 입출력 채널을 갖는 컴퓨터 시스템 선택 채널(select channel) 여러 개의 입출력장치가 연결되어 있다 하더라도 한 번에 단 하나의 입출력장치만을 선택적으로 지원 비교적 전송 속도가 빠른 입출력장치인 디스크나 CD-ROM 등의 입출력을 제어 멀티플렉서 채널(multiplexer channel) 다수의 저속도 입출력장치가 채널의 단일한 데이터 경로를 공유하면서 데이터를 전송 여러 개의 저속도 입출력장치가 멀티플렉서 채널에 연결되어 시분할(time­sharing) 형태로 제어 키보드나 프린터와 같은 비교적 전송 속도가 느린 입출력장치를 제어 채널과 중앙처리장치 간의 통신은 일반적으로 인터럽트(interrupt) [그림1-11] 다양한 형태의 채널 연결 구조 인터럽트(interrupt) 시스템에 예기치 않은 상황이 발생하였을 때, 그것을 운영체제에 알리기 위한 메커니즘 종류 입출력(I/O) 인터럽트 외부(external) 인터럽트 SVC(SuperVisor Call) 인터럽트 기계 검사(machine check) 인터럽트 프로그램 에러(program error) 인터럽트 재시작(restart) 인터럽트 구조 및 처리 [그림1-12] 인터럽트 처리 과정 [그림1-13] 인터럽트의 처리 과정 및 PSW 위치","link":"/Computer-Science/Operating-System/2019/08/06/Operating-System-01-introduce/"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","link":"/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Insertion Sort","slug":"Insertion-Sort","link":"/tags/Insertion-Sort/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Priority Queue","slug":"Priority-Queue","link":"/tags/Priority-Queue/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"}],"categories":[{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Data Structure","slug":"Computer-Science/Data-Structure","link":"/categories/Computer-Science/Data-Structure/"},{"name":"Algorithm","slug":"Computer-Science/Algorithm","link":"/categories/Computer-Science/Algorithm/"},{"name":"Devlog","slug":"Devlog","link":"/categories/Devlog/"},{"name":"Hexo","slug":"Devlog/Hexo","link":"/categories/Devlog/Hexo/"},{"name":"Operating System","slug":"Computer-Science/Operating-System","link":"/categories/Computer-Science/Operating-System/"}]}